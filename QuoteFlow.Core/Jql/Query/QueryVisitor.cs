using System;
using System.Linq;
using Lucene.Net.Search;
using QuoteFlow.Api.Jql.Query;
using QuoteFlow.Api.Jql.Query.Clause;
using QuoteFlow.Core.Jql.Clause;

namespace QuoteFlow.Core.Jql.Query
{
    /// <summary>
    /// Used to generate the Lucene query from a <see cref="IQuery"/>. This visits the nodes of the tree
    /// and creates a lucene query based on its structure. Users of this class should only call 
    /// <see cref="CreateQuery"/> and not use the visitor directly as the query in a 
    /// <see cref="QueryFactoryResult"/> may not be valid.
    /// </summary>
    public class QueryVisitor : IClauseVisitor<QueryFactoryResult>
    {
        private readonly IQueryRegistry _queryRegistry;
        private readonly IQueryCreationContext _queryCreationContext;
        private readonly DeMorgansVisitor _deMorgansVisitor;
        private readonly WasClauseQueryFactory _wasClauseQueryFactory;
        private readonly ChangedClauseQueryFactory _changedClauseQueryFactory;
        private bool _rootClause = true;

        public QueryVisitor(IQueryRegistry queryRegistry, IQueryCreationContext queryCreationContext, WasClauseQueryFactory wasClauseQueryFactory, ChangedClauseQueryFactory changedClauseQueryFactory)
            : this(queryRegistry, queryCreationContext, new DeMorgansVisitor(), wasClauseQueryFactory, changedClauseQueryFactory)
        {
        }

        public QueryVisitor(IQueryRegistry queryRegistry, IQueryCreationContext queryCreationContext, DeMorgansVisitor deMorgansVisitor, WasClauseQueryFactory wasClauseQueryFactory, ChangedClauseQueryFactory changedClauseQueryFactory)
        {
            _queryRegistry = queryRegistry;
            _queryCreationContext = queryCreationContext;
            _deMorgansVisitor = deMorgansVisitor;
            _wasClauseQueryFactory = wasClauseQueryFactory;
            _changedClauseQueryFactory = changedClauseQueryFactory;
        }

        /// <summary>
        /// Create a lucene query for the passed clause.
        /// <p/>
        /// NOTE: The query generated by this method will probably not run in Lucene even though it is correct. Lucene has
        /// some quirks when dealing with negative queries. Lucene will not search for negative queries, it will only filter
        /// the results from a positive query (e.g. +catalog:monkey -status:blocker will work while -status:blocker will
        /// not).
        /// 
        /// NOTE: This visitor will push all instances of the <see cref="NotClause"/> out of the tree
        /// by using the <seealso cref="DeMorgansVisitor"/> so that the terminal clauses will handle
        /// all the negation logic and the visitor does not need to deal with NOT's.
        /// </summary>
        /// <param name="clause"> the clause to process. </param>
        /// <returns> the generated lucene query. </returns>
        public virtual global::Lucene.Net.Search.Query CreateQuery(IClause clause)
        {
            // This method handles the root clause case
            _rootClause = false;
            IClause normalisedClause = clause.Accept(_deMorgansVisitor);
            QueryFactoryResult queryFactoryResult = normalisedClause.Accept(this);
            return MakeQuery(queryFactoryResult);
        }

        public virtual QueryFactoryResult Visit(AndClause andClause)
        {
            if (_rootClause)
            {
                return new QueryFactoryResult(CreateQuery(andClause));
            }

            if (andClause.Clauses.Count() > BooleanQuery.MaxClauseCount)
            {
                throw new JqlTooComplex(andClause);
            }

            var booleanQuery = new BooleanQuery();
            foreach (IClause clause in andClause.Clauses)
            {
                QueryFactoryResult queryFactoryResult = clause.Accept(this);
                if (queryFactoryResult.MustNotOccur)
                {
                    booleanQuery.Add(queryFactoryResult.LuceneQuery, Occur.MUST_NOT);
                }
                else
                {
                    booleanQuery.Add(queryFactoryResult.LuceneQuery, Occur.MUST);
                }
            }

            return new QueryFactoryResult(booleanQuery);
        }

        public virtual QueryFactoryResult Visit(OrClause orClause)
        {
            if (_rootClause)
            {
                return new QueryFactoryResult(CreateQuery(orClause));
            }

            if (orClause.Clauses.Count() > BooleanQuery.MaxClauseCount)
            {
                throw new JqlTooComplex(orClause);
            }

            var booleanQuery = new BooleanQuery();
            foreach (IClause clause in orClause.Clauses)
            {
                QueryFactoryResult queryFactoryResult = clause.Accept(this);
                booleanQuery.Add(MakeQuery(queryFactoryResult), Occur.SHOULD);
            }

            return new QueryFactoryResult(booleanQuery);
        }

        public virtual QueryFactoryResult Visit(NotClause notClause)
        {
            if (_rootClause)
            {
                return new QueryFactoryResult(CreateQuery(notClause));
            }

            throw new InvalidOperationException("We have removed all the NOT clauses from the query, this should never occur.");
        }

        public virtual QueryFactoryResult Visit(ITerminalClause terminalClause)
        {
            if (_rootClause)
            {
                return new QueryFactoryResult(CreateQuery(terminalClause));
            }
            var clauseQueryFactory = _queryRegistry.GetClauseQueryFactory(_queryCreationContext, terminalClause);

            if (clauseQueryFactory.Count == 0)
            {
                // This time we really mean it! When we are asked to run a query for things that no longer exist we will
                // run the query the best we can, adding false to the tree for bits that we can not resolve.
                return QueryFactoryResult.CreateFalseResult();
            }
            try
            {
                if (clauseQueryFactory.Count == 1)
                {
                    IClauseQueryFactory factory = clauseQueryFactory.First();
                    return factory.GetQuery(_queryCreationContext, terminalClause);
                }
                var query = new BooleanQuery();
                foreach (IClauseQueryFactory factory in clauseQueryFactory)
                {
                    query.Add(MakeQuery(factory.GetQuery(_queryCreationContext, terminalClause)), Occur.SHOULD);
                }
                return new QueryFactoryResult(query);
            }
            catch (BooleanQuery.TooManyClauses tooManyClauses)
            {
                throw new JqlTooComplex(terminalClause);
            }
            // This could happen for Factories that use their own QueryVisitors, e.g. SavedFilterCQF
            catch (JqlTooComplex jqlTooComplex)
            {
                throw new JqlTooComplex(terminalClause);
            }
        }

        QueryFactoryResult IClauseVisitor<QueryFactoryResult>.Visit(IWasClause clause)
        {
            return _wasClauseQueryFactory.Create(_queryCreationContext.User, clause);
        }

        public QueryFactoryResult Visit(IChangedClause clause)
        {
            return _changedClauseQueryFactory.Create(_queryCreationContext.User, clause);
        }

        private static global::Lucene.Net.Search.Query MakeQuery(QueryFactoryResult queryFactoryResult)
        {
            if (queryFactoryResult.MustNotOccur)
            {
                //we must wrap the thing in a boolean query so that the "mustNot" in the result is represented.
                var query = new BooleanQuery {{queryFactoryResult.LuceneQuery, Occur.MUST_NOT}};
                return query;
            }
            return queryFactoryResult.LuceneQuery;
        }

        /// <summary>
        /// This exception is thrown when the JQL Query is to complex to be generated into an Lucene Query.
        /// It is caught in <seealso cref="LuceneQueryBuilder"/> and converted into a <seealso cref="ClauseTooComplexSearchException"/>.
        /// </summary>
        internal class JqlTooComplex : Exception
        {
            internal JqlTooComplex(IClause clause)
            {
                Clause = clause;
            }

            public virtual IClause Clause { get; private set; }
        }
    }
}