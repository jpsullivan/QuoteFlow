//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g 2014-11-09 23:10:45

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;
using System.Collections;
using System.Linq;
using Antlr.Runtime;
using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using QuoteFlow.Api.Infrastructure.Extensions;
using QuoteFlow.Api.Jql.Parser;
using QuoteFlow.Api.Jql.Query;
using QuoteFlow.Api.Jql.Query.Clause;
using QuoteFlow.Api.Jql.Query.History;
using QuoteFlow.Api.Jql.Query.Operand;
using QuoteFlow.Api.Jql.Query.Order;
using QuoteFlow.Api.Jql.Util;
using QuoteFlow.Core.Jql.Antlr;
using QuoteFlow.Core.Jql.Query.Clause;
using QuoteFlow.Core.Jql.Query.History;
using QuoteFlow.Core.Jql.Util;
using JqlParseErrorMessages = QuoteFlow.Core.Jql.Parser.JqlParseErrorMessages;

namespace  QuoteFlow.Models.Search.Jql.AntlrGen 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class JqlParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AFTER", "AMPER", "AMPER_AMPER", "AND", "ASC", "BANG", "BEFORE", "BSLASH", "BY", "CHANGED", "COMMA", "CONTROLCHARS", "CR", "CUSTOMFIELD", "DESC", "DIGIT", "DURING", "EMPTY", "EQUALS", "ERRORCHAR", "ERROR_RESERVED", "ESCAPE", "FROM", "GT", "GTEQ", "HEXDIGIT", "IN", "IS", "LBRACKET", "LIKE", "LPAREN", "LT", "LTEQ", "MATCHWS", "MINUS", "NEGNUMBER", "NEWLINE", "NL", "NOT", "NOT_EQUALS", "NOT_LIKE", "ON", "OR", "ORDER", "PIPE", "PIPE_PIPE", "POSNUMBER", "QUOTE", "QUOTE_STRING", "RBRACKET", "RESERVED_CHARS", "RPAREN", "SPACE", "SQUOTE", "SQUOTE_STRING", "STRING", "STRINGSTOP", "TO", "WAS", "WS"
	};
	public const int EOF=-1;
	public const int AFTER=4;
	public const int AMPER=5;
	public const int AMPER_AMPER=6;
	public const int AND=7;
	public const int ASC=8;
	public const int BANG=9;
	public const int BEFORE=10;
	public const int BSLASH=11;
	public const int BY=12;
	public const int CHANGED=13;
	public const int COMMA=14;
	public const int CONTROLCHARS=15;
	public const int CR=16;
	public const int CUSTOMFIELD=17;
	public const int DESC=18;
	public const int DIGIT=19;
	public const int DURING=20;
	public const int EMPTY=21;
	public const int EQUALS=22;
	public const int ERRORCHAR=23;
	public const int ERROR_RESERVED=24;
	public const int ESCAPE=25;
	public const int FROM=26;
	public const int GT=27;
	public const int GTEQ=28;
	public const int HEXDIGIT=29;
	public const int IN=30;
	public const int IS=31;
	public const int LBRACKET=32;
	public const int LIKE=33;
	public const int LPAREN=34;
	public const int LT=35;
	public const int LTEQ=36;
	public const int MATCHWS=37;
	public const int MINUS=38;
	public const int NEGNUMBER=39;
	public const int NEWLINE=40;
	public const int NL=41;
	public const int NOT=42;
	public const int NOT_EQUALS=43;
	public const int NOT_LIKE=44;
	public const int ON=45;
	public const int OR=46;
	public const int ORDER=47;
	public const int PIPE=48;
	public const int PIPE_PIPE=49;
	public const int POSNUMBER=50;
	public const int QUOTE=51;
	public const int QUOTE_STRING=52;
	public const int RBRACKET=53;
	public const int RESERVED_CHARS=54;
	public const int RPAREN=55;
	public const int SPACE=56;
	public const int SQUOTE=57;
	public const int SQUOTE_STRING=58;
	public const int STRING=59;
	public const int STRINGSTOP=60;
	public const int TO=61;
	public const int WAS=62;
	public const int WS=63;

	public JqlParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public JqlParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return JqlParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g"; } }


		private int operandLevel = 0;
		private bool supportsHistoryPredicate = false;

		protected override object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow)
	    {
	        throw new MismatchedTokenException(ttype, input);
	    }

	    public override object RecoverFromMismatchedSet(IIntStream input, RecognitionException e, BitSet follow)
	    {
	        throw e;
	    }

	    public override void EmitErrorMessage(string msg)
	    {
	        base.EmitErrorMessage(msg);
	    }

	    /// <summary>
	    /// Make sure that the passed token can be turned into an int. In ANTLR there
	    /// does not appear to be an easy way to limit numbers to a valid Long range, so
	    /// lets do so in C#.
	    /// </summary>
	    /// <param name="token">The token to turn into an int.</param>
	    /// <returns>The valid int.</returns>
	    private int ParseInt(IToken token)
	    {
	        string text = token.Text;
	        try
	        {
	            return Convert.ToInt32(text);
	        }
	        catch (Exception e)
	        {
	            var message = JqlParseErrorMessages.IllegalNumber(text, token.Line, token.CharPositionInLine);
	            throw new RuntimeRecognitionException(message, e);
	        }
	    }

	    private string CheckFieldName(IToken token)
	    {
	        string text = token.Text;
	        if (text.IsNullOrEmpty())
	        {
	            ReportError(JqlParseErrorMessages.EmptyFieldName(token.Line, token.CharPositionInLine), null);
	        }
	        return text;
	    }

	    private string CheckFunctionName(IToken token)
	    {
	        string text = token.Text;
	        if (text.IsNullOrEmpty())
	        {
	            ReportError(JqlParseErrorMessages.EmptyFunctionName(token.Line, token.CharPositionInLine), null);
	        }
	        return text;
	    }

	    private void ReportError(JqlParseErrorMessage message, Exception th)
	    {
	        throw new RuntimeRecognitionException(message, th);
	    }



	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	public sealed partial class query_return : ParserRuleReturnScope<IToken>
	{
		public IClause clause;
		public IOrderBy order;
		public query_return(JqlParser grammar) {OnCreated(grammar);}
		partial void OnCreated(JqlParser grammar);
	}

	partial void EnterRule_query();
	partial void LeaveRule_query();
	// $ANTLR start "query"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:182:8: public query returns [IClause clause, IOrderBy order] : (where= clause )? (sort= orderBy )? EOF ;
	[GrammarRule("query")]
	public JqlParser.query_return query()
	{
		EnterRule_query();
		EnterRule("query", 1);
		TraceIn("query", 1);
		JqlParser.query_return retval = new JqlParser.query_return(this);
		retval.Start = (IToken)input.LT(1);

		IClause where = default(IClause);
		IOrderBy sort = default(IOrderBy);

		try { DebugEnterRule(GrammarFileName, "query");
		DebugLocation(182, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:183:2: ( (where= clause )? (sort= orderBy )? EOF )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:183:4: (where= clause )? (sort= orderBy )? EOF
			{
			DebugLocation(183, 4);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:183:4: (where= clause )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1==BANG||LA1_1==CUSTOMFIELD||LA1_1==LPAREN||LA1_1==NEGNUMBER||LA1_1==NOT||LA1_1==POSNUMBER||LA1_1==QUOTE_STRING||(LA1_1>=SQUOTE_STRING && LA1_1<=STRING)))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:183:5: where= clause
				{
				DebugLocation(183, 11);
				PushFollow(Follow._clause_in_query87);
				where=clause();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(183, 23);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:183:23: (sort= orderBy )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==ORDER))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:183:24: sort= orderBy
				{
				DebugLocation(183, 29);
				PushFollow(Follow._orderBy_in_query97);
				sort=orderBy();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(183, 41);
			Match(input,EOF,Follow._EOF_in_query101); 
			DebugLocation(184, 2);

					retval.clause = where;
					retval.order = sort;
				

			}

			retval.Stop = (IToken)input.LT(-1);

		}
		catch (MismatchedTokenException e)
		{

				    if (e.Expecting == EOF)
			        {
			            if (sort != null)
			            {
			                //If the sort has trailing tokens then "," must be the next token as this is the only way to
			                //continue a sort.
			                ReportError(JqlParseErrorMessages.ExpectedText(e.Token, ","), e);
			            }
			            else if (where == null)
			            {
			                //If there is no where clause, then we were not able to find a field name. If we found a field
			                //name we would have found a clause and got an error there.
			                ReportError(JqlParseErrorMessages.BadFieldName(e.Token), e);
			            }
			            else
			            {
			                //If we get a clause but have other stuff after, then the next token must be an "AND" or "OR" as this
			                //is the only valid way to combine two clauses.
			                ReportError(JqlParseErrorMessages.NeedLogicalOperator(e.Token), e);
			            }
			        }
				    ReportError(JqlParseErrorMessages.GenericParseError(e.Token), e);
				
		}
		catch (RecognitionException e)
		{

				    ReportError(JqlParseErrorMessages.GenericParseError(e.Token), e);
				
		}

		finally
		{
			TraceOut("query", 1);
			LeaveRule("query", 1);
			LeaveRule_query();
		}
		DebugLocation(188, 1);
		} finally { DebugExitRule(GrammarFileName, "query"); }
		return retval;

	}
	// $ANTLR end "query"

	partial void EnterRule_clause();
	partial void LeaveRule_clause();
	// $ANTLR start "clause"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:222:1: clause returns [IClause clause] : orClause ;
	[GrammarRule("clause")]
	private IClause clause()
	{
		EnterRule_clause();
		EnterRule("clause", 2);
		TraceIn("clause", 2);
		IClause clause = default(IClause);


		IClause orClause1 = default(IClause);

		try { DebugEnterRule(GrammarFileName, "clause");
		DebugLocation(222, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:223:2: ( orClause )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:223:4: orClause
			{
			DebugLocation(223, 4);
			PushFollow(Follow._orClause_in_clause137);
			orClause1=orClause();
			PopFollow();

			DebugLocation(223, 13);
			 clause = orClause1; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("clause", 2);
			LeaveRule("clause", 2);
			LeaveRule_clause();
		}
		DebugLocation(224, 1);
		} finally { DebugExitRule(GrammarFileName, "clause"); }
		return clause;

	}
	// $ANTLR end "clause"

	partial void EnterRule_orClause();
	partial void LeaveRule_orClause();
	// $ANTLR start "orClause"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:229:1: orClause returns [IClause clause] : cl= andClause ( OR cl= andClause )* ;
	[GrammarRule("orClause")]
	private IClause orClause()
	{
		EnterRule_orClause();
		EnterRule("orClause", 3);
		TraceIn("orClause", 3);
		IClause clause = default(IClause);


		IClause cl = default(IClause);


				var clauses = new List<IClause>();
			
		try { DebugEnterRule(GrammarFileName, "orClause");
		DebugLocation(229, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:234:2: (cl= andClause ( OR cl= andClause )* )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:234:4: cl= andClause ( OR cl= andClause )*
			{
			DebugLocation(234, 7);
			PushFollow(Follow._andClause_in_orClause168);
			cl=andClause();
			PopFollow();

			DebugLocation(234, 19);
			 clauses.Add(cl); 
			DebugLocation(234, 48);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:234:48: ( OR cl= andClause )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==OR))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:234:49: OR cl= andClause
					{
					DebugLocation(234, 49);
					Match(input,OR,Follow._OR_in_orClause173); 
					DebugLocation(234, 55);
					PushFollow(Follow._andClause_in_orClause179);
					cl=andClause();
					PopFollow();

					DebugLocation(234, 67);
					 clauses.Add(cl); 

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(234, 98);
			clause = clauses.Count == 1? clauses.ElementAt(0) : new OrClause(clauses); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("orClause", 3);
			LeaveRule("orClause", 3);
			LeaveRule_orClause();
		}
		DebugLocation(235, 1);
		} finally { DebugExitRule(GrammarFileName, "orClause"); }
		return clause;

	}
	// $ANTLR end "orClause"

	partial void EnterRule_andClause();
	partial void LeaveRule_andClause();
	// $ANTLR start "andClause"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:240:1: andClause returns [IClause clause] : cl= notClause ( AND cl= notClause )* ;
	[GrammarRule("andClause")]
	private IClause andClause()
	{
		EnterRule_andClause();
		EnterRule("andClause", 4);
		TraceIn("andClause", 4);
		IClause clause = default(IClause);


		IClause cl = default(IClause);


				var clauses = new List<IClause>();
			
		try { DebugEnterRule(GrammarFileName, "andClause");
		DebugLocation(240, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:244:2: (cl= notClause ( AND cl= notClause )* )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:244:4: cl= notClause ( AND cl= notClause )*
			{
			DebugLocation(244, 7);
			PushFollow(Follow._notClause_in_andClause212);
			cl=notClause();
			PopFollow();

			DebugLocation(244, 19);
			 clauses.Add(cl); 
			DebugLocation(244, 48);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:244:48: ( AND cl= notClause )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==AND))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:244:49: AND cl= notClause
					{
					DebugLocation(244, 49);
					Match(input,AND,Follow._AND_in_andClause217); 
					DebugLocation(244, 56);
					PushFollow(Follow._notClause_in_andClause223);
					cl=notClause();
					PopFollow();

					DebugLocation(244, 68);
					 clauses.Add(cl); 

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(244, 99);
			clause = clauses.Count == 1? clauses.ElementAt(0) : new AndClause(clauses); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("andClause", 4);
			LeaveRule("andClause", 4);
			LeaveRule_andClause();
		}
		DebugLocation(245, 1);
		} finally { DebugExitRule(GrammarFileName, "andClause"); }
		return clause;

	}
	// $ANTLR end "andClause"

	partial void EnterRule_notClause();
	partial void LeaveRule_notClause();
	// $ANTLR start "notClause"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:250:1: notClause returns [IClause clause] : ( ( NOT | BANG ) nc= notClause | subClause | terminalClause );
	[GrammarRule("notClause")]
	private IClause notClause()
	{
		EnterRule_notClause();
		EnterRule("notClause", 5);
		TraceIn("notClause", 5);
		IClause clause = default(IClause);


		IClause nc = default(IClause);
		IClause subClause2 = default(IClause);
		IClause terminalClause3 = default(IClause);

		try { DebugEnterRule(GrammarFileName, "notClause");
		DebugLocation(250, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:251:2: ( ( NOT | BANG ) nc= notClause | subClause | terminalClause )
			int alt5=3;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case BANG:
			case NOT:
				{
				alt5 = 1;
				}
				break;
			case LPAREN:
				{
				alt5 = 2;
				}
				break;
			case CUSTOMFIELD:
			case NEGNUMBER:
			case POSNUMBER:
			case QUOTE_STRING:
			case SQUOTE_STRING:
			case STRING:
				{
				alt5 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:251:4: ( NOT | BANG ) nc= notClause
				{
				DebugLocation(251, 4);
				if (input.LA(1)==BANG||input.LA(1)==NOT)
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(251, 20);
				PushFollow(Follow._notClause_in_notClause258);
				nc=notClause();
				PopFollow();

				DebugLocation(251, 32);
				 clause = new NotClause(nc); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:252:4: subClause
				{
				DebugLocation(252, 4);
				PushFollow(Follow._subClause_in_notClause265);
				subClause2=subClause();
				PopFollow();

				DebugLocation(252, 14);
				 clause = subClause2; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:253:25: terminalClause
				{
				DebugLocation(253, 25);
				PushFollow(Follow._terminalClause_in_notClause293);
				terminalClause3=terminalClause();
				PopFollow();

				DebugLocation(253, 40);
				 clause = terminalClause3; 

				}
				break;

			}
		}
		catch (NoViableAltException e)
		{

				    //If there is no option here then we assume that the user meant a field expression.
				    ReportError(JqlParseErrorMessages.BadFieldName(e.Token), e);
				
		}

		finally
		{
			TraceOut("notClause", 5);
			LeaveRule("notClause", 5);
			LeaveRule_notClause();
		}
		DebugLocation(254, 1);
		} finally { DebugExitRule(GrammarFileName, "notClause"); }
		return clause;

	}
	// $ANTLR end "notClause"

	partial void EnterRule_subClause();
	partial void LeaveRule_subClause();
	// $ANTLR start "subClause"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:265:1: subClause returns [IClause clause] : LPAREN orClause RPAREN ;
	[GrammarRule("subClause")]
	private IClause subClause()
	{
		EnterRule_subClause();
		EnterRule("subClause", 6);
		TraceIn("subClause", 6);
		IClause clause = default(IClause);


		IClause orClause4 = default(IClause);

		try { DebugEnterRule(GrammarFileName, "subClause");
		DebugLocation(265, 4);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:266:5: ( LPAREN orClause RPAREN )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:266:7: LPAREN orClause RPAREN
			{
			DebugLocation(266, 7);
			Match(input,LPAREN,Follow._LPAREN_in_subClause325); 
			DebugLocation(266, 14);
			PushFollow(Follow._orClause_in_subClause327);
			orClause4=orClause();
			PopFollow();

			DebugLocation(266, 23);
			Match(input,RPAREN,Follow._RPAREN_in_subClause329); 
			DebugLocation(266, 30);
			 clause = orClause4; 

			}

		}
		catch (MismatchedTokenException e)
		{

			        if (e.Expecting == RPAREN)
			        {
			            ReportError(JqlParseErrorMessages.ExpectedText(e.Token, ")"), e);
			        }
			        else
			        {
			            throw e;
			        }
			    
		}

		finally
		{
			TraceOut("subClause", 6);
			LeaveRule("subClause", 6);
			LeaveRule_subClause();
		}
		DebugLocation(267, 4);
		} finally { DebugExitRule(GrammarFileName, "subClause"); }
		return clause;

	}
	// $ANTLR end "subClause"

	partial void EnterRule_terminalClause();
	partial void LeaveRule_terminalClause();
	// $ANTLR start "terminalClause"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:283:1: terminalClause returns [IClause clause] : f= field op= operator ( (opand= operand (pred= historyPredicate )? ) | (chPred= historyPredicate )? ) ;
	[GrammarRule("terminalClause")]
	private IClause terminalClause()
	{
		EnterRule_terminalClause();
		EnterRule("terminalClause", 7);
		TraceIn("terminalClause", 7);
		IClause clause = default(IClause);


		ParserRuleReturnScope<IToken> f = default(ParserRuleReturnScope<IToken>);
		Operator op = default(Operator);
		IOperand opand = default(IOperand);
		IHistoryPredicate pred = default(IHistoryPredicate);
		IHistoryPredicate chPred = default(IHistoryPredicate);

		try { DebugEnterRule(GrammarFileName, "terminalClause");
		DebugLocation(283, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:2: (f= field op= operator ( (opand= operand (pred= historyPredicate )? ) | (chPred= historyPredicate )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:4: f= field op= operator ( (opand= operand (pred= historyPredicate )? ) | (chPred= historyPredicate )? )
			{
			DebugLocation(284, 6);
			PushFollow(Follow._field_in_terminalClause370);
			f=field();
			PopFollow();

			DebugLocation(284, 17);
			PushFollow(Follow._operator_in_terminalClause376);
			op=@operator();
			PopFollow();

			DebugLocation(284, 29);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:29: ( (opand= operand (pred= historyPredicate )? ) | (chPred= historyPredicate )? )
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==EMPTY||LA8_1==LPAREN||LA8_1==NEGNUMBER||LA8_1==POSNUMBER||LA8_1==QUOTE_STRING||(LA8_1>=SQUOTE_STRING && LA8_1<=STRING)))
			{
				alt8 = 1;
			}
			else if ((LA8_1==EOF||LA8_1==AFTER||LA8_1==AND||LA8_1==BEFORE||LA8_1==BY||LA8_1==DURING||LA8_1==FROM||(LA8_1>=ON && LA8_1<=ORDER)||LA8_1==RPAREN||LA8_1==TO))
			{
				alt8 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:31: (opand= operand (pred= historyPredicate )? )
				{
				DebugLocation(284, 31);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:31: (opand= operand (pred= historyPredicate )? )
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:32: opand= operand (pred= historyPredicate )?
				{
				DebugLocation(284, 38);
				PushFollow(Follow._operand_in_terminalClause386);
				opand=operand();
				PopFollow();

				DebugLocation(284, 52);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:52: (pred= historyPredicate )?
				int alt6=2;
				try { DebugEnterSubRule(6);
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==AFTER||LA6_1==BEFORE||LA6_1==BY||LA6_1==DURING||LA6_1==FROM||LA6_1==ON||LA6_1==TO))
				{
					alt6 = 1;
				}
				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:52: pred= historyPredicate
					{
					DebugLocation(284, 52);
					PushFollow(Follow._historyPredicate_in_terminalClause391);
					pred=historyPredicate();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(6); }


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:75: (chPred= historyPredicate )?
				{
				DebugLocation(284, 81);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:81: (chPred= historyPredicate )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==AFTER||LA7_1==BEFORE||LA7_1==BY||LA7_1==DURING||LA7_1==FROM||LA7_1==ON||LA7_1==TO))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:284:81: chPred= historyPredicate
					{
					DebugLocation(284, 81);
					PushFollow(Follow._historyPredicate_in_terminalClause399);
					chPred=historyPredicate();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(7); }


				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(285, 2);

			        if (f != null && (f!=null?((JqlParser.field_return)f).field:default(FieldReference)).IsEntityProperty())
			        {
			            if (opand == null)
			            {
			                var e = new RecognitionException(input);
			                ReportError(JqlParseErrorMessages.BadOperand(e.Token), e);
			            }
			            clause = new TerminalClause((f!=null?((JqlParser.field_return)f).field:default(FieldReference)).Name, op, opand, new List<Property>{(f!=null?((JqlParser.field_return)f).field:default(FieldReference)).Property});
			        }
				    else if (op  == Operator.CHANGED)
				    {
			            if (opand != null)
			            {
			                var e = new RecognitionException(input);
			                ReportError(JqlParseErrorMessages.UnsupportedOperand(op.ToString(), opand.DisplayString),e);
			            }
			            clause = new ChangedClause((f!=null?((JqlParser.field_return)f).field:default(FieldReference)).Name, op, chPred);
				    }
				    else
				    {
				       if (op == Operator.WAS || op == Operator.WAS_NOT || op == Operator.WAS_IN || op == Operator.WAS_NOT_IN )
					   {
					        if (opand == null)
			                {
			                    var e = new RecognitionException(input);
			                    ReportError(JqlParseErrorMessages.BadOperand(e.Token), e);
			                }
			                clause = new WasClause((f!=null?((JqlParser.field_return)f).field:default(FieldReference)).Name, op, opand, pred);
			                supportsHistoryPredicate=true;
			           }
			           else
			           {
					        if (opand == null)
			                {
			                    var e = new RecognitionException(input);
			                    ReportError(JqlParseErrorMessages.BadOperand(e.Token), e);
			                }
			                clause = new TerminalClause((f!=null?((JqlParser.field_return)f).field:default(FieldReference)).Name, op, opand);
			                supportsHistoryPredicate=false;
			                if (pred != null)
			                {
			                    var errorMessage = JqlParseErrorMessages.UnsupportedPredicate(pred.DisplayString, op.ToString());
			                    JqlParseException exception = new JqlParseException(errorMessage);
			                    ReportError(errorMessage, exception);
			                }
			           }
			        }
				

			}

		}
		catch (RecognitionException e)
		{

				    // Because of the ANTLR lookahead, these ain't actually called ;-)
				    if (f == null)
				    {
				        ReportError(JqlParseErrorMessages.BadFieldName(e.Token), e);
				    }
				    else if (op == null)
				    {
				        ReportError(JqlParseErrorMessages.BadOperator(e.Token), e);
				    }
				    else if (opand == null)
				    {
				        ReportError(JqlParseErrorMessages.BadOperand(e.Token), e);
				    }
				    else
				    {
				        ReportError(JqlParseErrorMessages.GenericParseError(e.Token), e);
				    }
				
		}

		finally
		{
			TraceOut("terminalClause", 7);
			LeaveRule("terminalClause", 7);
			LeaveRule_terminalClause();
		}
		DebugLocation(334, 1);
		} finally { DebugExitRule(GrammarFileName, "terminalClause"); }
		return clause;

	}
	// $ANTLR end "terminalClause"

	partial void EnterRule_historyPredicate();
	partial void LeaveRule_historyPredicate();
	// $ANTLR start "historyPredicate"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:357:1: historyPredicate returns [IHistoryPredicate predicate] : (p= terminalHistoryPredicate )+ ;
	[GrammarRule("historyPredicate")]
	private IHistoryPredicate historyPredicate()
	{
		EnterRule_historyPredicate();
		EnterRule("historyPredicate", 8);
		TraceIn("historyPredicate", 8);
		IHistoryPredicate predicate = default(IHistoryPredicate);


		IHistoryPredicate p = default(IHistoryPredicate);


				var predicates = new List<IHistoryPredicate>();
			
		try { DebugEnterRule(GrammarFileName, "historyPredicate");
		DebugLocation(357, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:361:2: ( (p= terminalHistoryPredicate )+ )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:361:4: (p= terminalHistoryPredicate )+
			{
			DebugLocation(361, 4);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:361:4: (p= terminalHistoryPredicate )+
			int cnt9=0;
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==AFTER||LA9_1==BEFORE||LA9_1==BY||LA9_1==DURING||LA9_1==FROM||LA9_1==ON||LA9_1==TO))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:361:5: p= terminalHistoryPredicate
					{
					DebugLocation(361, 7);
					PushFollow(Follow._terminalHistoryPredicate_in_historyPredicate439);
					p=terminalHistoryPredicate();
					PopFollow();

					DebugLocation(361, 34);
					 predicates.Add(p);

					}
					break;

				default:
					if (cnt9 >= 1)
						goto loop9;

					EarlyExitException eee9 = new EarlyExitException( 9, input );
					DebugRecognitionException(eee9);
					throw eee9;
				}
				cnt9++;
			}
			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(361, 69);
			predicate = predicates.Count == 1? predicates.ElementAt(0) : new AndHistoryPredicate(predicates); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("historyPredicate", 8);
			LeaveRule("historyPredicate", 8);
			LeaveRule_historyPredicate();
		}
		DebugLocation(362, 1);
		} finally { DebugExitRule(GrammarFileName, "historyPredicate"); }
		return predicate;

	}
	// $ANTLR end "historyPredicate"

	partial void EnterRule_terminalHistoryPredicate();
	partial void LeaveRule_terminalHistoryPredicate();
	// $ANTLR start "terminalHistoryPredicate"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:425:1: terminalHistoryPredicate returns [IHistoryPredicate predicate] : historyPredicateOperator operand ;
	[GrammarRule("terminalHistoryPredicate")]
	private IHistoryPredicate terminalHistoryPredicate()
	{
		EnterRule_terminalHistoryPredicate();
		EnterRule("terminalHistoryPredicate", 9);
		TraceIn("terminalHistoryPredicate", 9);
		IHistoryPredicate predicate = default(IHistoryPredicate);


		Operator historyPredicateOperator5 = default(Operator);
		IOperand operand6 = default(IOperand);

		try { DebugEnterRule(GrammarFileName, "terminalHistoryPredicate");
		DebugLocation(425, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:426:2: ( historyPredicateOperator operand )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:426:4: historyPredicateOperator operand
			{
			DebugLocation(426, 4);
			PushFollow(Follow._historyPredicateOperator_in_terminalHistoryPredicate463);
			historyPredicateOperator5=historyPredicateOperator();
			PopFollow();

			DebugLocation(426, 29);
			PushFollow(Follow._operand_in_terminalHistoryPredicate465);
			operand6=operand();
			PopFollow();

			DebugLocation(427, 2);

					predicate = new TerminalHistoryPredicate(historyPredicateOperator5, operand6);
				

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("terminalHistoryPredicate", 9);
			LeaveRule("terminalHistoryPredicate", 9);
			LeaveRule_terminalHistoryPredicate();
		}
		DebugLocation(430, 1);
		} finally { DebugExitRule(GrammarFileName, "terminalHistoryPredicate"); }
		return predicate;

	}
	// $ANTLR end "terminalHistoryPredicate"

	partial void EnterRule_historyPredicateOperator();
	partial void LeaveRule_historyPredicateOperator();
	// $ANTLR start "historyPredicateOperator"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:433:1: historyPredicateOperator returns [Operator oprator] : ( FROM | TO | BY | BEFORE | AFTER | ON | DURING );
	[GrammarRule("historyPredicateOperator")]
	private Operator historyPredicateOperator()
	{
		EnterRule_historyPredicateOperator();
		EnterRule("historyPredicateOperator", 10);
		TraceIn("historyPredicateOperator", 10);
		Operator oprator = default(Operator);


		try { DebugEnterRule(GrammarFileName, "historyPredicateOperator");
		DebugLocation(433, 39);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:434:2: ( FROM | TO | BY | BEFORE | AFTER | ON | DURING )
			int alt10=7;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case FROM:
				{
				alt10 = 1;
				}
				break;
			case TO:
				{
				alt10 = 2;
				}
				break;
			case BY:
				{
				alt10 = 3;
				}
				break;
			case BEFORE:
				{
				alt10 = 4;
				}
				break;
			case AFTER:
				{
				alt10 = 5;
				}
				break;
			case ON:
				{
				alt10 = 6;
				}
				break;
			case DURING:
				{
				alt10 = 7;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:434:4: FROM
				{
				DebugLocation(434, 4);
				Match(input,FROM,Follow._FROM_in_historyPredicateOperator484); 
				DebugLocation(434, 9);
				 oprator = Operator.FROM; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:435:4: TO
				{
				DebugLocation(435, 4);
				Match(input,TO,Follow._TO_in_historyPredicateOperator491); 
				DebugLocation(435, 7);
				oprator = Operator.TO; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:436:4: BY
				{
				DebugLocation(436, 4);
				Match(input,BY,Follow._BY_in_historyPredicateOperator498); 
				DebugLocation(436, 7);
				oprator = Operator.BY; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:437:4: BEFORE
				{
				DebugLocation(437, 4);
				Match(input,BEFORE,Follow._BEFORE_in_historyPredicateOperator505); 
				DebugLocation(437, 11);
				oprator = Operator.BEFORE; 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:438:4: AFTER
				{
				DebugLocation(438, 4);
				Match(input,AFTER,Follow._AFTER_in_historyPredicateOperator512); 
				DebugLocation(438, 10);
				oprator = Operator.AFTER; 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:439:4: ON
				{
				DebugLocation(439, 4);
				Match(input,ON,Follow._ON_in_historyPredicateOperator519); 
				DebugLocation(439, 7);
				oprator = Operator.ON; 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:440:4: DURING
				{
				DebugLocation(440, 4);
				Match(input,DURING,Follow._DURING_in_historyPredicateOperator527); 
				DebugLocation(440, 11);
				oprator = Operator.DURING;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("historyPredicateOperator", 10);
			LeaveRule("historyPredicateOperator", 10);
			LeaveRule_historyPredicateOperator();
		}
		DebugLocation(440, 39);
		} finally { DebugExitRule(GrammarFileName, "historyPredicateOperator"); }
		return oprator;

	}
	// $ANTLR end "historyPredicateOperator"

	partial void EnterRule_operator();
	partial void LeaveRule_operator();
	// $ANTLR start "operator"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:447:1: operator returns [Operator oprator] : ( EQUALS | NOT_EQUALS | LIKE | NOT_LIKE | LT | GT | LTEQ | GTEQ | IN | IS NOT | IS | NOT IN | WAS | WAS NOT | WAS IN | WAS NOT IN | CHANGED );
	[GrammarRule("operator")]
	private Operator @operator()
	{
		EnterRule_operator();
		EnterRule("operator", 11);
		TraceIn("operator", 11);
		Operator oprator = default(Operator);


		try { DebugEnterRule(GrammarFileName, "operator");
		DebugLocation(447, 4);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:448:2: ( EQUALS | NOT_EQUALS | LIKE | NOT_LIKE | LT | GT | LTEQ | GTEQ | IN | IS NOT | IS | NOT IN | WAS | WAS NOT | WAS IN | WAS NOT IN | CHANGED )
			int alt11=17;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case EQUALS:
				{
				alt11 = 1;
				}
				break;
			case NOT_EQUALS:
				{
				alt11 = 2;
				}
				break;
			case LIKE:
				{
				alt11 = 3;
				}
				break;
			case NOT_LIKE:
				{
				alt11 = 4;
				}
				break;
			case LT:
				{
				alt11 = 5;
				}
				break;
			case GT:
				{
				alt11 = 6;
				}
				break;
			case LTEQ:
				{
				alt11 = 7;
				}
				break;
			case GTEQ:
				{
				alt11 = 8;
				}
				break;
			case IN:
				{
				alt11 = 9;
				}
				break;
			case IS:
				{
				int LA11_2 = input.LA(2);

				if ((LA11_2==NOT))
				{
					alt11 = 10;
				}
				else if ((LA11_2==EOF||LA11_2==AFTER||LA11_2==AND||LA11_2==BEFORE||LA11_2==BY||(LA11_2>=DURING && LA11_2<=EMPTY)||LA11_2==FROM||LA11_2==LPAREN||LA11_2==NEGNUMBER||(LA11_2>=ON && LA11_2<=ORDER)||LA11_2==POSNUMBER||LA11_2==QUOTE_STRING||LA11_2==RPAREN||(LA11_2>=SQUOTE_STRING && LA11_2<=STRING)||LA11_2==TO))
				{
					alt11 = 11;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NOT:
				{
				alt11 = 12;
				}
				break;
			case WAS:
				{
				switch (input.LA(2))
				{
				case NOT:
					{
					int LA11_3 = input.LA(3);

					if ((LA11_3==IN))
					{
						alt11 = 16;
					}
					else if ((LA11_3==EOF||LA11_3==AFTER||LA11_3==AND||LA11_3==BEFORE||LA11_3==BY||(LA11_3>=DURING && LA11_3<=EMPTY)||LA11_3==FROM||LA11_3==LPAREN||LA11_3==NEGNUMBER||(LA11_3>=ON && LA11_3<=ORDER)||LA11_3==POSNUMBER||LA11_3==QUOTE_STRING||LA11_3==RPAREN||(LA11_3>=SQUOTE_STRING && LA11_3<=STRING)||LA11_3==TO))
					{
						alt11 = 14;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 11, 16, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case IN:
					{
					alt11 = 15;
					}
					break;
				case EOF:
				case AFTER:
				case AND:
				case BEFORE:
				case BY:
				case DURING:
				case EMPTY:
				case FROM:
				case LPAREN:
				case NEGNUMBER:
				case ON:
				case OR:
				case ORDER:
				case POSNUMBER:
				case QUOTE_STRING:
				case RPAREN:
				case SQUOTE_STRING:
				case STRING:
				case TO:
					{
					alt11 = 13;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 11, 12, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case CHANGED:
				{
				alt11 = 17;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:448:4: EQUALS
				{
				DebugLocation(448, 4);
				Match(input,EQUALS,Follow._EQUALS_in_operator548); 
				DebugLocation(448, 11);
				 oprator = Operator.EQUALS; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:449:4: NOT_EQUALS
				{
				DebugLocation(449, 4);
				Match(input,NOT_EQUALS,Follow._NOT_EQUALS_in_operator555); 
				DebugLocation(449, 15);
				 oprator = Operator.NOT_EQUALS; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:450:4: LIKE
				{
				DebugLocation(450, 4);
				Match(input,LIKE,Follow._LIKE_in_operator562); 
				DebugLocation(450, 9);
				 oprator = Operator.LIKE; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:451:4: NOT_LIKE
				{
				DebugLocation(451, 4);
				Match(input,NOT_LIKE,Follow._NOT_LIKE_in_operator569); 
				DebugLocation(451, 13);
				 oprator = Operator.NOT_LIKE; 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:452:4: LT
				{
				DebugLocation(452, 4);
				Match(input,LT,Follow._LT_in_operator577); 
				DebugLocation(452, 7);
				 oprator = Operator.LESS_THAN; 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:453:4: GT
				{
				DebugLocation(453, 4);
				Match(input,GT,Follow._GT_in_operator584); 
				DebugLocation(453, 7);
				 oprator = Operator.GREATER_THAN; 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:454:4: LTEQ
				{
				DebugLocation(454, 4);
				Match(input,LTEQ,Follow._LTEQ_in_operator591); 
				DebugLocation(454, 9);
				 oprator = Operator.LESS_THAN_EQUALS; 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:455:4: GTEQ
				{
				DebugLocation(455, 4);
				Match(input,GTEQ,Follow._GTEQ_in_operator598); 
				DebugLocation(455, 9);
				 oprator = Operator.GREATER_THAN_EQUALS; 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:456:4: IN
				{
				DebugLocation(456, 4);
				Match(input,IN,Follow._IN_in_operator605); 
				DebugLocation(456, 7);
				 oprator = Operator.IN; 

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:457:4: IS NOT
				{
				DebugLocation(457, 4);
				Match(input,IS,Follow._IS_in_operator612); 
				DebugLocation(457, 7);
				Match(input,NOT,Follow._NOT_in_operator614); 
				DebugLocation(457, 11);
				 oprator = Operator.IS_NOT; 

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:458:4: IS
				{
				DebugLocation(458, 4);
				Match(input,IS,Follow._IS_in_operator621); 
				DebugLocation(458, 7);
				 oprator = Operator.IS; 

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:459:4: NOT IN
				{
				DebugLocation(459, 4);
				Match(input,NOT,Follow._NOT_in_operator628); 
				DebugLocation(459, 8);
				Match(input,IN,Follow._IN_in_operator630); 
				DebugLocation(459, 11);
				 oprator = Operator.NOT_IN; 

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:460:4: WAS
				{
				DebugLocation(460, 4);
				Match(input,WAS,Follow._WAS_in_operator637); 
				DebugLocation(460, 8);
				 oprator = Operator.WAS; 

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:461:4: WAS NOT
				{
				DebugLocation(461, 4);
				Match(input,WAS,Follow._WAS_in_operator644); 
				DebugLocation(461, 8);
				Match(input,NOT,Follow._NOT_in_operator646); 
				DebugLocation(461, 12);
				 oprator = Operator.WAS_NOT; 

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:462:7: WAS IN
				{
				DebugLocation(462, 7);
				Match(input,WAS,Follow._WAS_in_operator656); 
				DebugLocation(462, 11);
				Match(input,IN,Follow._IN_in_operator658); 
				DebugLocation(462, 14);
				 oprator = Operator.WAS_IN; 

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:463:7: WAS NOT IN
				{
				DebugLocation(463, 7);
				Match(input,WAS,Follow._WAS_in_operator668); 
				DebugLocation(463, 11);
				Match(input,NOT,Follow._NOT_in_operator670); 
				DebugLocation(463, 15);
				Match(input,IN,Follow._IN_in_operator672); 
				DebugLocation(463, 18);
				 oprator = Operator.WAS_NOT_IN; 

				}
				break;
			case 17:
				DebugEnterAlt(17);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:464:7: CHANGED
				{
				DebugLocation(464, 7);
				Match(input,CHANGED,Follow._CHANGED_in_operator682); 
				DebugLocation(464, 15);
				 oprator = Operator.CHANGED; 

				}
				break;

			}
		}
		catch (MismatchedTokenException e)
		{

				    //This will only get thrown when we read in "IS" or "NOT" not followed by its correct string.
			        if (e.Expecting == NOT)
			        {
			            ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "NOT"), e);
			        }
			        else if (e.Expecting == IN)
			        {
			            ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "IN"), e);
			        }
			        else
			        {
			            // We will do this just in case.
			            ReportError(JqlParseErrorMessages.BadOperator(e.Token), e);
			        }
				
		}
		catch (RecognitionException e)
		{

			        IToken currentToken = input.LT(1);
			        if (currentToken.Type == IS)
			        {
			            // This happens when we get an IS is not followed by a NOT.
			            ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "NOT"), e);
			        }
			        else if (currentToken.Type == NOT)
			        {
			            // This happens when we get a NOT is not followed by a IN.
			            ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "IN"), e);
			        }
			        else if (currentToken.Type == WAS)
			        {
			            ReportError(JqlParseErrorMessages.BadOperand(e.Token),e);
			        }
			        else
			        {
			            ReportError(JqlParseErrorMessages.BadOperator(e.Token), e);
			        }
			    
		}

		finally
		{
			TraceOut("operator", 11);
			LeaveRule("operator", 11);
			LeaveRule_operator();
		}
		DebugLocation(465, 4);
		} finally { DebugExitRule(GrammarFileName, "operator"); }
		return oprator;

	}
	// $ANTLR end "operator"

	private sealed partial class field_return : ParserRuleReturnScope<IToken>
	{
		public FieldReference field;
		public field_return(JqlParser grammar) {OnCreated(grammar);}
		partial void OnCreated(JqlParser grammar);
	}

	partial void EnterRule_field();
	partial void LeaveRule_field();
	// $ANTLR start "field"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:509:1: field returns [FieldReference field] : (num= numberString | ( (str= string |cf= customField ) ( ( LBRACKET (reff= argument ) RBRACKET ) (reff= propertyArgument )* )* ) );
	[GrammarRule("field")]
	private JqlParser.field_return field()
	{
		EnterRule_field();
		EnterRule("field", 12);
		TraceIn("field", 12);
		JqlParser.field_return retval = new JqlParser.field_return(this);
		retval.Start = (IToken)input.LT(1);

		ParserRuleReturnScope<IToken> num = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> str = default(ParserRuleReturnScope<IToken>);
		string cf = default(string);
		string reff = default(string);


		        var names = new List<string>();
		        var arrays = new List<string>();
		        var propertyRefs = new List<string>();
		    
		try { DebugEnterRule(GrammarFileName, "field");
		DebugLocation(509, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:518:2: (num= numberString | ( (str= string |cf= customField ) ( ( LBRACKET (reff= argument ) RBRACKET ) (reff= propertyArgument )* )* ) )
			int alt15=2;
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==NEGNUMBER||LA15_1==POSNUMBER))
			{
				alt15 = 1;
			}
			else if ((LA15_1==CUSTOMFIELD||LA15_1==QUOTE_STRING||(LA15_1>=SQUOTE_STRING && LA15_1<=STRING)))
			{
				alt15 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:519:5: num= numberString
				{
				DebugLocation(519, 9);
				PushFollow(Follow._numberString_in_field746);
				num=numberString();
				PopFollow();

				DebugLocation(519, 24);
				 names.Add((num!=null?((JqlParser.numberString_return)num).stringValue:default(String))); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:521:5: ( (str= string |cf= customField ) ( ( LBRACKET (reff= argument ) RBRACKET ) (reff= propertyArgument )* )* )
				{
				DebugLocation(521, 5);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:521:5: ( (str= string |cf= customField ) ( ( LBRACKET (reff= argument ) RBRACKET ) (reff= propertyArgument )* )* )
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:522:9: (str= string |cf= customField ) ( ( LBRACKET (reff= argument ) RBRACKET ) (reff= propertyArgument )* )*
				{
				DebugLocation(522, 9);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:522:9: (str= string |cf= customField )
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==QUOTE_STRING||(LA12_1>=SQUOTE_STRING && LA12_1<=STRING)))
				{
					alt12 = 1;
				}
				else if ((LA12_1==CUSTOMFIELD))
				{
					alt12 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:523:13: str= string
					{
					DebugLocation(523, 17);
					PushFollow(Follow._string_in_field788);
					str=@string();
					PopFollow();

					DebugLocation(523, 26);
					 names.Add(CheckFieldName((str!=null?((IToken)str.Start):default(IToken)))); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:524:15: cf= customField
					{
					DebugLocation(524, 18);
					PushFollow(Follow._customField_in_field810);
					cf=customField();
					PopFollow();

					DebugLocation(524, 32);
					 names.Add(cf); 

					}
					break;

				}
				} finally { DebugExitSubRule(12); }

				DebugLocation(526, 9);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:526:9: ( ( LBRACKET (reff= argument ) RBRACKET ) (reff= propertyArgument )* )*
				try { DebugEnterSubRule(14);
				while (true)
				{
					int alt14=2;
					try { DebugEnterDecision(14, false);
					int LA14_1 = input.LA(1);

					if ((LA14_1==LBRACKET))
					{
						alt14 = 1;
					}


					} finally { DebugExitDecision(14); }
					switch ( alt14 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:527:10: ( LBRACKET (reff= argument ) RBRACKET ) (reff= propertyArgument )*
						{
						DebugLocation(527, 10);
						// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:527:10: ( LBRACKET (reff= argument ) RBRACKET )
						DebugEnterAlt(1);
						// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:528:14: LBRACKET (reff= argument ) RBRACKET
						{
						DebugLocation(528, 14);
						Match(input,LBRACKET,Follow._LBRACKET_in_field858); 
						DebugLocation(529, 14);
						// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:529:14: (reff= argument )
						DebugEnterAlt(1);
						// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:530:18: reff= argument
						{
						DebugLocation(530, 23);
						PushFollow(Follow._argument_in_field896);
						reff=argument();
						PopFollow();

						DebugLocation(530, 34);
						arrays.Add(reff);

						}

						DebugLocation(532, 14);
						Match(input,RBRACKET,Follow._RBRACKET_in_field928); 

						}

						DebugLocation(534, 10);
						// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:534:10: (reff= propertyArgument )*
						try { DebugEnterSubRule(13);
						while (true)
						{
							int alt13=2;
							try { DebugEnterDecision(13, false);
							int LA13_1 = input.LA(1);

							if ((LA13_1==NEGNUMBER||LA13_1==POSNUMBER||LA13_1==QUOTE_STRING||(LA13_1>=SQUOTE_STRING && LA13_1<=STRING)))
							{
								alt13 = 1;
							}


							} finally { DebugExitDecision(13); }
							switch ( alt13 )
							{
							case 1:
								DebugEnterAlt(1);
								// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:535:14: reff= propertyArgument
								{
								DebugLocation(535, 19);
								PushFollow(Follow._propertyArgument_in_field969);
								reff=propertyArgument();
								PopFollow();

								DebugLocation(535, 38);
								propertyRefs.Add(reff);

								}
								break;

							default:
								goto loop13;
							}
						}

						loop13:
							;

						} finally { DebugExitSubRule(13); }


						}
						break;

					default:
						goto loop14;
					}
				}

				loop14:
					;

				} finally { DebugExitSubRule(14); }


				}


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);


			        retval.field = new FieldReference(names, arrays, propertyRefs);
			    
		}
		catch (MismatchedTokenException e)
		{

				    switch (e.Expecting)
				    {
				        case LBRACKET:
			                ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "["), e);
			                break;
			            case RBRACKET:
			                ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "]"), e);
			                break;
				    }
				
		}
		catch (EarlyExitException e)
		{

			        ReportError(JqlParseErrorMessages.BadPropertyArgument(e.Token), e);
				
		}
		catch (RecognitionException e)
		{

				    if (e.Token.Type == LBRACKET)
			        {
			            // We probably have some sort of custom field id that does not start with cf. Lets tell the user all about it.
			            ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "cf"), e);
			        }
			        else
			        {
			            ReportError(JqlParseErrorMessages.BadFieldName(e.Token), e);
			        }
				
		}

		finally
		{
			TraceOut("field", 12);
			LeaveRule("field", 12);
			LeaveRule_field();
		}
		DebugLocation(539, 1);
		} finally { DebugExitRule(GrammarFileName, "field"); }
		return retval;

	}
	// $ANTLR end "field"

	partial void EnterRule_customField();
	partial void LeaveRule_customField();
	// $ANTLR start "customField"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:569:1: customField returns [string field] : CUSTOMFIELD LBRACKET posnum= POSNUMBER RBRACKET ;
	[GrammarRule("customField")]
	private string customField()
	{
		EnterRule_customField();
		EnterRule("customField", 13);
		TraceIn("customField", 13);
		string field = default(string);


		IToken posnum = default(IToken);

		try { DebugEnterRule(GrammarFileName, "customField");
		DebugLocation(569, 4);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:570:5: ( CUSTOMFIELD LBRACKET posnum= POSNUMBER RBRACKET )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:570:7: CUSTOMFIELD LBRACKET posnum= POSNUMBER RBRACKET
			{
			DebugLocation(570, 7);
			Match(input,CUSTOMFIELD,Follow._CUSTOMFIELD_in_customField1039); 
			DebugLocation(570, 19);
			Match(input,LBRACKET,Follow._LBRACKET_in_customField1041); 
			DebugLocation(570, 35);
			posnum=(IToken)Match(input,POSNUMBER,Follow._POSNUMBER_in_customField1047); 
			DebugLocation(570, 47);
			Match(input,RBRACKET,Follow._RBRACKET_in_customField1049); 
			DebugLocation(570, 56);
			 field = JqlCustomFieldId.ToString(ParseInt(posnum)); 

			}

		}
		catch (MismatchedTokenException e)
		{

			        switch(e.Expecting)
			        {
			            case CUSTOMFIELD:
			                ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "cf"), e);
			                break;
			            case LBRACKET:
			                ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "["), e);
			                break;
			            case POSNUMBER:
			                ReportError(JqlParseErrorMessages.BadCustomFieldId(e.Token), e);
			                break;
			            case RBRACKET:
			                ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "]"), e);
			                break;
			            default:
			                throw e;
			        }
			    
		}

		finally
		{
			TraceOut("customField", 13);
			LeaveRule("customField", 13);
			LeaveRule_customField();
		}
		DebugLocation(571, 4);
		} finally { DebugExitRule(GrammarFileName, "customField"); }
		return field;

	}
	// $ANTLR end "customField"

	partial void EnterRule_fieldCheck();
	partial void LeaveRule_fieldCheck();
	// $ANTLR start "fieldCheck"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:596:8: public fieldCheck returns [FieldReference fieldRef] : f= field EOF ;
	[GrammarRule("fieldCheck")]
	public FieldReference fieldCheck()
	{
		EnterRule_fieldCheck();
		EnterRule("fieldCheck", 14);
		TraceIn("fieldCheck", 14);
		FieldReference fieldRef = default(FieldReference);


		ParserRuleReturnScope<IToken> f = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "fieldCheck");
		DebugLocation(596, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:597:2: (f= field EOF )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:597:4: f= field EOF
			{
			DebugLocation(597, 6);
			PushFollow(Follow._field_in_fieldCheck1091);
			f=field();
			PopFollow();

			DebugLocation(597, 14);
			 fieldRef = (f!=null?((JqlParser.field_return)f).field:default(FieldReference)); 
			DebugLocation(597, 40);
			Match(input,EOF,Follow._EOF_in_fieldCheck1095); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("fieldCheck", 14);
			LeaveRule("fieldCheck", 14);
			LeaveRule_fieldCheck();
		}
		DebugLocation(598, 1);
		} finally { DebugExitRule(GrammarFileName, "fieldCheck"); }
		return fieldRef;

	}
	// $ANTLR end "fieldCheck"

	partial void EnterRule_operand();
	partial void LeaveRule_operand();
	// $ANTLR start "operand"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:603:1: operand returns [IOperand operand] : ( EMPTY |str= string |number= numberString |fn= func |l= list );
	[GrammarRule("operand")]
	private IOperand operand()
	{
		EnterRule_operand();
		EnterRule("operand", 15);
		TraceIn("operand", 15);
		IOperand operand = default(IOperand);


		ParserRuleReturnScope<IToken> str = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> number = default(ParserRuleReturnScope<IToken>);
		FunctionOperand fn = default(FunctionOperand);
		IOperand l = default(IOperand);

		try { DebugEnterRule(GrammarFileName, "operand");
		DebugLocation(603, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:604:2: ( EMPTY |str= string |number= numberString |fn= func |l= list )
			int alt16=5;
			try { DebugEnterDecision(16, false);
			switch (input.LA(1))
			{
			case EMPTY:
				{
				alt16 = 1;
				}
				break;
			case STRING:
				{
				int LA16_2 = input.LA(2);

				if ((LA16_2==EOF||LA16_2==AFTER||LA16_2==AND||LA16_2==BEFORE||LA16_2==BY||LA16_2==COMMA||LA16_2==DURING||LA16_2==FROM||(LA16_2>=ON && LA16_2<=ORDER)||LA16_2==RPAREN||LA16_2==TO))
				{
					alt16 = 2;
				}
				else if ((LA16_2==LPAREN))
				{
					alt16 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case QUOTE_STRING:
				{
				int LA16_2 = input.LA(2);

				if ((LA16_2==EOF||LA16_2==AFTER||LA16_2==AND||LA16_2==BEFORE||LA16_2==BY||LA16_2==COMMA||LA16_2==DURING||LA16_2==FROM||(LA16_2>=ON && LA16_2<=ORDER)||LA16_2==RPAREN||LA16_2==TO))
				{
					alt16 = 2;
				}
				else if ((LA16_2==LPAREN))
				{
					alt16 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case SQUOTE_STRING:
				{
				int LA16_2 = input.LA(2);

				if ((LA16_2==EOF||LA16_2==AFTER||LA16_2==AND||LA16_2==BEFORE||LA16_2==BY||LA16_2==COMMA||LA16_2==DURING||LA16_2==FROM||(LA16_2>=ON && LA16_2<=ORDER)||LA16_2==RPAREN||LA16_2==TO))
				{
					alt16 = 2;
				}
				else if ((LA16_2==LPAREN))
				{
					alt16 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NEGNUMBER:
			case POSNUMBER:
				{
				int LA16_2 = input.LA(2);

				if ((LA16_2==EOF||LA16_2==AFTER||LA16_2==AND||LA16_2==BEFORE||LA16_2==BY||LA16_2==COMMA||LA16_2==DURING||LA16_2==FROM||(LA16_2>=ON && LA16_2<=ORDER)||LA16_2==RPAREN||LA16_2==TO))
				{
					alt16 = 3;
				}
				else if ((LA16_2==LPAREN))
				{
					alt16 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LPAREN:
				{
				alt16 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:604:4: EMPTY
				{
				DebugLocation(604, 4);
				Match(input,EMPTY,Follow._EMPTY_in_operand1112); 
				DebugLocation(604, 10);
				 operand = new EmptyOperand(); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:605:4: str= string
				{
				DebugLocation(605, 8);
				PushFollow(Follow._string_in_operand1123);
				str=@string();
				PopFollow();

				DebugLocation(605, 17);
				 operand = new SingleValueOperand((str!=null?((JqlParser.string_return)str).stringValue:default(String))); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:606:4: number= numberString
				{
				DebugLocation(606, 11);
				PushFollow(Follow._numberString_in_operand1134);
				number=numberString();
				PopFollow();

				DebugLocation(606, 26);
				 operand = new SingleValueOperand(ParseInt((number!=null?((IToken)number.Start):default(IToken)))); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:607:4: fn= func
				{
				DebugLocation(607, 7);
				PushFollow(Follow._func_in_operand1145);
				fn=func();
				PopFollow();

				DebugLocation(607, 14);
				operand = fn;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:608:4: l= list
				{
				DebugLocation(608, 6);
				PushFollow(Follow._list_in_operand1156);
				l=list();
				PopFollow();

				DebugLocation(608, 13);
				operand = l;

				}
				break;

			}
		}
		catch (NoViableAltException e)
		{

			        IToken currentToken = input.LT(1);
			        IToken errorToken = e.Token;

			        //HACKETY, HACKETY HACK. ANTLR uses a DFA to decide which type of operand we are going to handle. This DFA
			        //will only find "string" if it is followed by one of {EOF, OR, AND, RPAREN, COMMA, ORDER}. This means that
			        //a query like "a=b c=d" will actually fail here and appear to be an illegal operand. So we use a simple
			        //heuristic here. If the currentToken != errorToken then it means we have a valid value its just that we
			        //have not seen one of the expected trailing tokens.

			        if (currentToken.TokenIndex < errorToken.TokenIndex)
			        {
			            if (operandLevel <= 0)
			            {
			                // If not in a MutliValueOperand, we probably mean "AND" and "OR"
			                ReportError(JqlParseErrorMessages.NeedLogicalOperator(errorToken), e);
			            }
			            else
			            {
			                // If in a MutliValueOperand, we probably mean "," or ")".
			                ReportError(JqlParseErrorMessages.ExpectedText(errorToken, ",", ")"), e);
			            }
			        }
			        else
			        {
			            ReportError(JqlParseErrorMessages.BadOperand(errorToken), e);
			        }
				
		}
		catch (RecognitionException e)
		{

				    ReportError(JqlParseErrorMessages.BadOperand(e.Token), e);
				
		}

		finally
		{
			TraceOut("operand", 15);
			LeaveRule("operand", 15);
			LeaveRule_operand();
		}
		DebugLocation(609, 1);
		} finally { DebugExitRule(GrammarFileName, "operand"); }
		return operand;

	}
	// $ANTLR end "operand"

	private sealed partial class string_return : ParserRuleReturnScope<IToken>
	{
		public String stringValue;
		public string_return(JqlParser grammar) {OnCreated(grammar);}
		partial void OnCreated(JqlParser grammar);
	}

	partial void EnterRule_string();
	partial void LeaveRule_string();
	// $ANTLR start "string"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:647:1: string returns [String stringValue] : (str= STRING |str= QUOTE_STRING |str= SQUOTE_STRING );
	[GrammarRule("string")]
	private JqlParser.string_return @string()
	{
		EnterRule_string();
		EnterRule("string", 16);
		TraceIn("string", 16);
		JqlParser.string_return retval = new JqlParser.string_return(this);
		retval.Start = (IToken)input.LT(1);

		IToken str = default(IToken);

		try { DebugEnterRule(GrammarFileName, "string");
		DebugLocation(647, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:648:2: (str= STRING |str= QUOTE_STRING |str= SQUOTE_STRING )
			int alt17=3;
			try { DebugEnterDecision(17, false);
			switch (input.LA(1))
			{
			case STRING:
				{
				alt17 = 1;
				}
				break;
			case QUOTE_STRING:
				{
				alt17 = 2;
				}
				break;
			case SQUOTE_STRING:
				{
				alt17 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:648:4: str= STRING
				{
				DebugLocation(648, 8);
				str=(IToken)Match(input,STRING,Follow._STRING_in_string1196); 
				DebugLocation(648, 17);
				 retval.stringValue = (str!=null?str.Text:default(string)); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:649:4: str= QUOTE_STRING
				{
				DebugLocation(649, 8);
				str=(IToken)Match(input,QUOTE_STRING,Follow._QUOTE_STRING_in_string1207); 
				DebugLocation(649, 23);
				 retval.stringValue = (str!=null?str.Text:default(string)); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:650:4: str= SQUOTE_STRING
				{
				DebugLocation(650, 8);
				str=(IToken)Match(input,SQUOTE_STRING,Follow._SQUOTE_STRING_in_string1218); 
				DebugLocation(650, 24);
				 retval.stringValue = (str!=null?str.Text:default(string)); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("string", 16);
			LeaveRule("string", 16);
			LeaveRule_string();
		}
		DebugLocation(651, 1);
		} finally { DebugExitRule(GrammarFileName, "string"); }
		return retval;

	}
	// $ANTLR end "string"

	private sealed partial class numberString_return : ParserRuleReturnScope<IToken>
	{
		public String stringValue;
		public numberString_return(JqlParser grammar) {OnCreated(grammar);}
		partial void OnCreated(JqlParser grammar);
	}

	partial void EnterRule_numberString();
	partial void LeaveRule_numberString();
	// $ANTLR start "numberString"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:653:1: numberString returns [String stringValue] : num= ( POSNUMBER | NEGNUMBER ) ;
	[GrammarRule("numberString")]
	private JqlParser.numberString_return numberString()
	{
		EnterRule_numberString();
		EnterRule("numberString", 17);
		TraceIn("numberString", 17);
		JqlParser.numberString_return retval = new JqlParser.numberString_return(this);
		retval.Start = (IToken)input.LT(1);

		IToken num = default(IToken);

		try { DebugEnterRule(GrammarFileName, "numberString");
		DebugLocation(653, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:654:2: (num= ( POSNUMBER | NEGNUMBER ) )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:654:4: num= ( POSNUMBER | NEGNUMBER )
			{
			DebugLocation(654, 8);

			num=(IToken)input.LT(1);
			if (input.LA(1)==NEGNUMBER||input.LA(1)==POSNUMBER)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(654, 34);
			 retval.stringValue = (num!=null?num.Text:default(string)); 

			}

			retval.Stop = (IToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("numberString", 17);
			LeaveRule("numberString", 17);
			LeaveRule_numberString();
		}
		DebugLocation(655, 1);
		} finally { DebugExitRule(GrammarFileName, "numberString"); }
		return retval;

	}
	// $ANTLR end "numberString"

	partial void EnterRule_stringValueCheck();
	partial void LeaveRule_stringValueCheck();
	// $ANTLR start "stringValueCheck"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:660:8: public stringValueCheck returns [String stringValue] : str= string EOF ;
	[GrammarRule("stringValueCheck")]
	public String stringValueCheck()
	{
		EnterRule_stringValueCheck();
		EnterRule("stringValueCheck", 18);
		TraceIn("stringValueCheck", 18);
		String stringValue = default(String);


		ParserRuleReturnScope<IToken> str = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "stringValueCheck");
		DebugLocation(660, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:661:2: (str= string EOF )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:661:4: str= string EOF
			{
			DebugLocation(661, 8);
			PushFollow(Follow._string_in_stringValueCheck1270);
			str=@string();
			PopFollow();

			DebugLocation(661, 17);
			 stringValue = (str!=null?((JqlParser.string_return)str).stringValue:default(String)); 
			DebugLocation(661, 54);
			Match(input,EOF,Follow._EOF_in_stringValueCheck1274); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("stringValueCheck", 18);
			LeaveRule("stringValueCheck", 18);
			LeaveRule_stringValueCheck();
		}
		DebugLocation(662, 1);
		} finally { DebugExitRule(GrammarFileName, "stringValueCheck"); }
		return stringValue;

	}
	// $ANTLR end "stringValueCheck"

	partial void EnterRule_list();
	partial void LeaveRule_list();
	// $ANTLR start "list"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:667:1: list returns [IOperand list] : LPAREN opnd= operand ( COMMA opnd= operand )* RPAREN ;
	[GrammarRule("list")]
	private IOperand list()
	{
		EnterRule_list();
		EnterRule("list", 19);
		TraceIn("list", 19);
		IOperand list = default(IOperand);


		IOperand opnd = default(IOperand);


				List<IOperand> args = new List<IOperand>();
				operandLevel++;
			
		try { DebugEnterRule(GrammarFileName, "list");
		DebugLocation(667, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:675:2: ( LPAREN opnd= operand ( COMMA opnd= operand )* RPAREN )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:675:4: LPAREN opnd= operand ( COMMA opnd= operand )* RPAREN
			{
			DebugLocation(675, 4);
			Match(input,LPAREN,Follow._LPAREN_in_list1304); 
			DebugLocation(675, 16);
			PushFollow(Follow._operand_in_list1310);
			opnd=operand();
			PopFollow();

			DebugLocation(675, 26);
			args.Add(opnd);
			DebugLocation(676, 3);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:676:3: ( COMMA opnd= operand )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==COMMA))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:676:4: COMMA opnd= operand
					{
					DebugLocation(676, 4);
					Match(input,COMMA,Follow._COMMA_in_list1318); 
					DebugLocation(676, 15);
					PushFollow(Follow._operand_in_list1324);
					opnd=operand();
					PopFollow();

					DebugLocation(676, 25);
					args.Add(opnd);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(676, 54);
			Match(input,RPAREN,Follow._RPAREN_in_list1330); 
			DebugLocation(676, 61);
			list = new MultiValueOperand(args);

			}


				    operandLevel--;
				
		}
		catch (MismatchedTokenException e)
		{

			        if (e.Expecting == RPAREN)
			        {
			            ReportError(JqlParseErrorMessages.ExpectedText(e.Token, ")"), e);
			        }
			        else
			        {
			            throw e;
			        }
			    
		}

		finally
		{
			TraceOut("list", 19);
			LeaveRule("list", 19);
			LeaveRule_list();
		}
		DebugLocation(677, 1);
		} finally { DebugExitRule(GrammarFileName, "list"); }
		return list;

	}
	// $ANTLR end "list"

	partial void EnterRule_func();
	partial void LeaveRule_func();
	// $ANTLR start "func"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:693:1: func returns [FunctionOperand func] : fname= funcName LPAREN ( arglist )? RPAREN ;
	[GrammarRule("func")]
	private FunctionOperand func()
	{
		EnterRule_func();
		EnterRule("func", 20);
		TraceIn("func", 20);
		FunctionOperand func = default(FunctionOperand);


		string fname = default(string);
		List<string> arglist7 = default(List<string>);

		try { DebugEnterRule(GrammarFileName, "func");
		DebugLocation(693, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:694:2: (fname= funcName LPAREN ( arglist )? RPAREN )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:694:4: fname= funcName LPAREN ( arglist )? RPAREN
			{
			DebugLocation(694, 10);
			PushFollow(Follow._funcName_in_func1368);
			fname=funcName();
			PopFollow();

			DebugLocation(694, 21);
			Match(input,LPAREN,Follow._LPAREN_in_func1370); 
			DebugLocation(694, 28);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:694:28: ( arglist )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_1 = input.LA(1);

			if ((LA19_1==NEGNUMBER||LA19_1==POSNUMBER||LA19_1==QUOTE_STRING||(LA19_1>=SQUOTE_STRING && LA19_1<=STRING)))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:694:28: arglist
				{
				DebugLocation(694, 28);
				PushFollow(Follow._arglist_in_func1372);
				arglist7=arglist();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(19); }

			DebugLocation(694, 37);
			Match(input,RPAREN,Follow._RPAREN_in_func1375); 
			DebugLocation(695, 2);

				    List<string> args = arglist7 == null ? new List<string>() : arglist7;
			        func = new FunctionOperand(fname, args);
			    

			}

		}
		catch (MismatchedTokenException e)
		{

				    // We should only get here when the query is trying to match ')'.
			        if (e.Expecting == RPAREN)
			        {
			            if (e.Token.Type == EOF || e.Token.Type == COMMA)
			            {
			                ReportError(JqlParseErrorMessages.ExpectedText(e.Token, ")"), e);
			            }
			            else
			            {
			                // There is some argument that is not a string or number.
			                ReportError(JqlParseErrorMessages.BadFunctionArgument(e.Token), e);
			            }
			        }
			        else
			        {
			            ReportError(JqlParseErrorMessages.GenericParseError(e.Token), e);
			        }
			    
		}
		catch (RecognitionException e)
		{

			        ReportError(JqlParseErrorMessages.GenericParseError(e.Token), e);
				
		}

		finally
		{
			TraceOut("func", 20);
			LeaveRule("func", 20);
			LeaveRule_func();
		}
		DebugLocation(699, 1);
		} finally { DebugExitRule(GrammarFileName, "func"); }
		return func;

	}
	// $ANTLR end "func"

	partial void EnterRule_funcName();
	partial void LeaveRule_funcName();
	// $ANTLR start "funcName"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:728:1: funcName returns [string name] : ( string |num= numberString );
	[GrammarRule("funcName")]
	private string funcName()
	{
		EnterRule_funcName();
		EnterRule("funcName", 21);
		TraceIn("funcName", 21);
		string name = default(string);


		ParserRuleReturnScope<IToken> num = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> string8 = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "funcName");
		DebugLocation(728, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:729:2: ( string |num= numberString )
			int alt20=2;
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==QUOTE_STRING||(LA20_1>=SQUOTE_STRING && LA20_1<=STRING)))
			{
				alt20 = 1;
			}
			else if ((LA20_1==NEGNUMBER||LA20_1==POSNUMBER))
			{
				alt20 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:729:4: string
				{
				DebugLocation(729, 4);
				PushFollow(Follow._string_in_funcName1412);
				string8=@string();
				PopFollow();

				DebugLocation(729, 11);
				 name = CheckFunctionName((string8!=null?((IToken)string8.Start):default(IToken))); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:730:4: num= numberString
				{
				DebugLocation(730, 8);
				PushFollow(Follow._numberString_in_funcName1423);
				num=numberString();
				PopFollow();

				DebugLocation(730, 23);
				 name = (num!=null?((JqlParser.numberString_return)num).stringValue:default(String)); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcName", 21);
			LeaveRule("funcName", 21);
			LeaveRule_funcName();
		}
		DebugLocation(731, 1);
		} finally { DebugExitRule(GrammarFileName, "funcName"); }
		return name;

	}
	// $ANTLR end "funcName"

	partial void EnterRule_funcNameCheck();
	partial void LeaveRule_funcNameCheck();
	// $ANTLR start "funcNameCheck"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:736:8: public funcNameCheck returns [string name] : fname= funcName EOF ;
	[GrammarRule("funcNameCheck")]
	public string funcNameCheck()
	{
		EnterRule_funcNameCheck();
		EnterRule("funcNameCheck", 22);
		TraceIn("funcNameCheck", 22);
		string name = default(string);


		string fname = default(string);

		try { DebugEnterRule(GrammarFileName, "funcNameCheck");
		DebugLocation(736, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:737:2: (fname= funcName EOF )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:737:4: fname= funcName EOF
			{
			DebugLocation(737, 10);
			PushFollow(Follow._funcName_in_funcNameCheck1449);
			fname=funcName();
			PopFollow();

			DebugLocation(737, 21);
			 name = fname; 
			DebugLocation(737, 46);
			Match(input,EOF,Follow._EOF_in_funcNameCheck1453); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("funcNameCheck", 22);
			LeaveRule("funcNameCheck", 22);
			LeaveRule_funcNameCheck();
		}
		DebugLocation(738, 1);
		} finally { DebugExitRule(GrammarFileName, "funcNameCheck"); }
		return name;

	}
	// $ANTLR end "funcNameCheck"

	partial void EnterRule_arglist();
	partial void LeaveRule_arglist();
	// $ANTLR start "arglist"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:743:1: arglist returns [List<string> args] : str= argument ( COMMA str= argument )* ;
	[GrammarRule("arglist")]
	private List<string> arglist()
	{
		EnterRule_arglist();
		EnterRule("arglist", 23);
		TraceIn("arglist", 23);
		List<string> args = default(List<string>);


		string str = default(string);


				args = new List<string>();
			
		try { DebugEnterRule(GrammarFileName, "arglist");
		DebugLocation(743, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:757:2: (str= argument ( COMMA str= argument )* )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:757:4: str= argument ( COMMA str= argument )*
			{
			DebugLocation(757, 8);
			PushFollow(Follow._argument_in_arglist1486);
			str=argument();
			PopFollow();

			DebugLocation(757, 19);
			 args.Add(str); 
			DebugLocation(758, 2);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:758:2: ( COMMA str= argument )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if ((LA21_1==COMMA))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:758:3: COMMA str= argument
					{
					DebugLocation(758, 3);
					Match(input,COMMA,Follow._COMMA_in_arglist1492); 
					DebugLocation(758, 13);
					PushFollow(Follow._argument_in_arglist1498);
					str=argument();
					PopFollow();

					DebugLocation(758, 24);
					 args.Add(str); 

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}


				    // ANTLR will exit the arg list after the first token that is NOT a comma. If we exit and we are not
				    // at the end of the argument list, then we have an error.

				    IToken currentToken = input.LT(1);
				    if (currentToken.Type != EOF && currentToken.Type != RPAREN)
			        {
			            ReportError(JqlParseErrorMessages.ExpectedText(currentToken, ")", ","), null);
			        }
				
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("arglist", 23);
			LeaveRule("arglist", 23);
			LeaveRule_arglist();
		}
		DebugLocation(759, 1);
		} finally { DebugExitRule(GrammarFileName, "arglist"); }
		return args;

	}
	// $ANTLR end "arglist"

	partial void EnterRule_propertyArgument();
	partial void LeaveRule_propertyArgument();
	// $ANTLR start "propertyArgument"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:761:1: propertyArgument returns [string arg] : a= argument ;
	[GrammarRule("propertyArgument")]
	private string propertyArgument()
	{
		EnterRule_propertyArgument();
		EnterRule("propertyArgument", 24);
		TraceIn("propertyArgument", 24);
		string arg = default(string);


		string a = default(string);

		try { DebugEnterRule(GrammarFileName, "propertyArgument");
		DebugLocation(761, 5);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:762:2: (a= argument )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:762:4: a= argument
			{
			DebugLocation(762, 6);
			PushFollow(Follow._argument_in_propertyArgument1522);
			a=argument();
			PopFollow();

			DebugLocation(763, 2);

				    // property argument should at least contain one dot and property reference
				        if (a.Length<2 || a[0] != '.' || a[1] == '.')
			            {

			                IToken currentToken = input.LT(-1);
			                if(input.Get(input.LT(-1).TokenIndex-1).Type == MATCHWS )
			                {
			                    ReportError(JqlParseErrorMessages.BadOperator(currentToken), null);
			                }
			                else
			                {
			                    ReportError(JqlParseErrorMessages.BadPropertyArgument(currentToken), null);
			                }
			            }
			            // remove leading dot as this is unnecessary
			            arg = a.Substring(1);

			    

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("propertyArgument", 24);
			LeaveRule("propertyArgument", 24);
			LeaveRule_propertyArgument();
		}
		DebugLocation(781, 5);
		} finally { DebugExitRule(GrammarFileName, "propertyArgument"); }
		return arg;

	}
	// $ANTLR end "propertyArgument"

	partial void EnterRule_argument();
	partial void LeaveRule_argument();
	// $ANTLR start "argument"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:786:1: argument returns [string arg] : (str= string |number= numberString );
	[GrammarRule("argument")]
	private string argument()
	{
		EnterRule_argument();
		EnterRule("argument", 25);
		TraceIn("argument", 25);
		string arg = default(string);


		ParserRuleReturnScope<IToken> str = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> number = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "argument");
		DebugLocation(786, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:787:2: (str= string |number= numberString )
			int alt22=2;
			try { DebugEnterDecision(22, false);
			int LA22_1 = input.LA(1);

			if ((LA22_1==QUOTE_STRING||(LA22_1>=SQUOTE_STRING && LA22_1<=STRING)))
			{
				alt22 = 1;
			}
			else if ((LA22_1==NEGNUMBER||LA22_1==POSNUMBER))
			{
				alt22 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 22, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:787:4: str= string
				{
				DebugLocation(787, 8);
				PushFollow(Follow._string_in_argument1544);
				str=@string();
				PopFollow();

				DebugLocation(787, 17);
				 arg = (str!=null?((JqlParser.string_return)str).stringValue:default(String)); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:788:4: number= numberString
				{
				DebugLocation(788, 11);
				PushFollow(Follow._numberString_in_argument1556);
				number=numberString();
				PopFollow();

				DebugLocation(788, 26);
				 arg = (number!=null?((JqlParser.numberString_return)number).stringValue:default(String)); 

				}
				break;

			}
		}
		catch (RecognitionException e)
		{

				    switch (e.Token.Type)
				    {
				        case COMMA:
				        case RPAREN:
				            ReportError(JqlParseErrorMessages.EmptyFunctionArgument(e.Token), e);
			                break;
			            case RBRACKET:
			                ReportError(JqlParseErrorMessages.BadPropertyArgument(e.Token), e);
			                break;
			            default:
			                ReportError(JqlParseErrorMessages.BadFunctionArgument(e.Token), e);
			                break;
				    }
				
		}

		finally
		{
			TraceOut("argument", 25);
			LeaveRule("argument", 25);
			LeaveRule_argument();
		}
		DebugLocation(789, 1);
		} finally { DebugExitRule(GrammarFileName, "argument"); }
		return arg;

	}
	// $ANTLR end "argument"

	partial void EnterRule_argumentCheck();
	partial void LeaveRule_argumentCheck();
	// $ANTLR start "argumentCheck"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:810:8: public argumentCheck returns [string arg] : a= argument EOF ;
	[GrammarRule("argumentCheck")]
	public string argumentCheck()
	{
		EnterRule_argumentCheck();
		EnterRule("argumentCheck", 26);
		TraceIn("argumentCheck", 26);
		string arg = default(string);


		string a = default(string);

		try { DebugEnterRule(GrammarFileName, "argumentCheck");
		DebugLocation(810, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:811:2: (a= argument EOF )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:811:4: a= argument EOF
			{
			DebugLocation(811, 6);
			PushFollow(Follow._argument_in_argumentCheck1589);
			a=argument();
			PopFollow();

			DebugLocation(811, 17);
			 arg = a; 
			DebugLocation(811, 36);
			Match(input,EOF,Follow._EOF_in_argumentCheck1593); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("argumentCheck", 26);
			LeaveRule("argumentCheck", 26);
			LeaveRule_argumentCheck();
		}
		DebugLocation(812, 1);
		} finally { DebugExitRule(GrammarFileName, "argumentCheck"); }
		return arg;

	}
	// $ANTLR end "argumentCheck"

	partial void EnterRule_orderBy();
	partial void LeaveRule_orderBy();
	// $ANTLR start "orderBy"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:817:1: orderBy returns [IOrderBy order] : ORDER BY f= searchSort ( COMMA f= searchSort )* ;
	[GrammarRule("orderBy")]
	private IOrderBy orderBy()
	{
		EnterRule_orderBy();
		EnterRule("orderBy", 27);
		TraceIn("orderBy", 27);
		IOrderBy order = default(IOrderBy);


		SearchSort f = default(SearchSort);


				List<SearchSort> args = new List<SearchSort>();
			
		try { DebugEnterRule(GrammarFileName, "orderBy");
		DebugLocation(817, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:821:2: ( ORDER BY f= searchSort ( COMMA f= searchSort )* )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:821:4: ORDER BY f= searchSort ( COMMA f= searchSort )*
			{
			DebugLocation(821, 4);
			Match(input,ORDER,Follow._ORDER_in_orderBy1617); 
			DebugLocation(821, 10);
			Match(input,BY,Follow._BY_in_orderBy1619); 
			DebugLocation(821, 15);
			PushFollow(Follow._searchSort_in_orderBy1625);
			f=searchSort();
			PopFollow();

			DebugLocation(821, 28);
			 args.Add(f); 
			DebugLocation(822, 3);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:822:3: ( COMMA f= searchSort )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if ((LA23_1==COMMA))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:822:4: COMMA f= searchSort
					{
					DebugLocation(822, 4);
					Match(input,COMMA,Follow._COMMA_in_orderBy1632); 
					DebugLocation(822, 12);
					PushFollow(Follow._searchSort_in_orderBy1638);
					f=searchSort();
					PopFollow();

					DebugLocation(822, 25);
					 args.Add(f); 

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }

			DebugLocation(822, 44);
			 order = new OrderBy(args); 

			}

		}
		catch (MismatchedTokenException e)
		{

			        if (e.Expecting == BY)
			        {
			            ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "by"), e);
			        }
			        else if (e.Expecting == ORDER)
			        {
			            // This should not happen since the lookahead ensures that ORDER has been matched.
			            ReportError(JqlParseErrorMessages.ExpectedText(e.Token, "order"), e);
			        }
			        else
			        {
			            ReportError(JqlParseErrorMessages.GenericParseError(e.Token), e);
			        }
				
		}
		catch (RecognitionException e)
		{

				    ReportError(JqlParseErrorMessages.GenericParseError(e.Token), e);
				
		}

		finally
		{
			TraceOut("orderBy", 27);
			LeaveRule("orderBy", 27);
			LeaveRule_orderBy();
		}
		DebugLocation(823, 1);
		} finally { DebugExitRule(GrammarFileName, "orderBy"); }
		return order;

	}
	// $ANTLR end "orderBy"

	partial void EnterRule_searchSort();
	partial void LeaveRule_searchSort();
	// $ANTLR start "searchSort"
	// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:848:1: searchSort returns [SearchSort sort] : f= field (o= DESC |o= ASC )? ;
	[GrammarRule("searchSort")]
	private SearchSort searchSort()
	{
		EnterRule_searchSort();
		EnterRule("searchSort", 28);
		TraceIn("searchSort", 28);
		SearchSort sort = default(SearchSort);


		IToken o = default(IToken);
		ParserRuleReturnScope<IToken> f = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "searchSort");
		DebugLocation(848, 1);
		try
		{
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:849:2: (f= field (o= DESC |o= ASC )? )
			DebugEnterAlt(1);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:849:4: f= field (o= DESC |o= ASC )?
			{
			DebugLocation(849, 6);
			PushFollow(Follow._field_in_searchSort1681);
			f=field();
			PopFollow();

			DebugLocation(849, 14);
			// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:849:14: (o= DESC |o= ASC )?
			int alt24=3;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1==DESC))
			{
				alt24 = 1;
			}
			else if ((LA24_1==ASC))
			{
				alt24 = 2;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:849:15: o= DESC
				{
				DebugLocation(849, 17);
				o=(IToken)Match(input,DESC,Follow._DESC_in_searchSort1688); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\jaysc_000\\Documents\\GitHub\\QuoteFlow\\QuoteFlow\\Models\\Search\\Jql\\Jql.g:849:26: o= ASC
				{
				DebugLocation(849, 28);
				o=(IToken)Match(input,ASC,Follow._ASC_in_searchSort1696); 

				}
				break;

			}
			} finally { DebugExitSubRule(24); }

			DebugLocation(850, 2);

				    if (o == null)
				    {
				        IToken token = input.LT(1);
				        // ANTLR is not very strict here. If ANTLR sees an illegal sort order, then it will simply leave
				        // the order by clause. We want to be a little stricter and find illegal SORT ORDERS.
				        if (token.Type != EOF && token.Type != COMMA)
				        {
				            ReportError(JqlParseErrorMessages.BadSortOrder(token), null);
				        }
				    }

				    SortOrder order = (o == null) ? SortOrder.ASC : SortOrderHelpers.ParseString((o!=null?o.Text:default(string)));
				    if (f != null && (f!=null?((JqlParser.field_return)f).field:default(FieldReference)).IsEntityProperty())
				    {
				        sort = new SearchSort((f!=null?((JqlParser.field_return)f).field:default(FieldReference)).Name, new List<Property>{(f!=null?((JqlParser.field_return)f).field:default(FieldReference)).Property}, order);
				    }
				    else
				    {
					    sort = new SearchSort((f!=null?input.ToString(f.Start,f.Stop):default(string)), order);
					}
				

			}

		}
		catch (RecognitionException e)
		{

				    if (f == null)
				    {
			            // We could not find a field.
			            ReportError(JqlParseErrorMessages.BadFieldName(e.Token), e);
				    }
				    else
				    {
				        // We could not find a correct order.
				        ReportError(JqlParseErrorMessages.BadSortOrder(e.Token), e);
				    }
				
		}

		finally
		{
			TraceOut("searchSort", 28);
			LeaveRule("searchSort", 28);
			LeaveRule_searchSort();
		}
		DebugLocation(872, 1);
		} finally { DebugExitRule(GrammarFileName, "searchSort"); }
		return sort;

	}
	// $ANTLR end "searchSort"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _clause_in_query87 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _orderBy_in_query97 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_query101 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _orClause_in_clause137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _andClause_in_orClause168 = new BitSet(new ulong[]{0x400000000002UL});
		public static readonly BitSet _OR_in_orClause173 = new BitSet(new ulong[]{0xC14048400020200UL});
		public static readonly BitSet _andClause_in_orClause179 = new BitSet(new ulong[]{0x400000000002UL});
		public static readonly BitSet _notClause_in_andClause212 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _AND_in_andClause217 = new BitSet(new ulong[]{0xC14048400020200UL});
		public static readonly BitSet _notClause_in_andClause223 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _set_in_notClause246 = new BitSet(new ulong[]{0xC14048400020200UL});
		public static readonly BitSet _notClause_in_notClause258 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _subClause_in_notClause265 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _terminalClause_in_notClause293 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_subClause325 = new BitSet(new ulong[]{0xC14048400020200UL});
		public static readonly BitSet _orClause_in_subClause327 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _RPAREN_in_subClause329 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _field_in_terminalClause370 = new BitSet(new ulong[]{0x40001C1AD8402000UL});
		public static readonly BitSet _operator_in_terminalClause376 = new BitSet(new ulong[]{0x2C14208404301412UL});
		public static readonly BitSet _operand_in_terminalClause386 = new BitSet(new ulong[]{0x2000200004101412UL});
		public static readonly BitSet _historyPredicate_in_terminalClause391 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _historyPredicate_in_terminalClause399 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _terminalHistoryPredicate_in_historyPredicate439 = new BitSet(new ulong[]{0x2000200004101412UL});
		public static readonly BitSet _historyPredicateOperator_in_terminalHistoryPredicate463 = new BitSet(new ulong[]{0xC14008400200000UL});
		public static readonly BitSet _operand_in_terminalHistoryPredicate465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FROM_in_historyPredicateOperator484 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TO_in_historyPredicateOperator491 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BY_in_historyPredicateOperator498 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BEFORE_in_historyPredicateOperator505 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AFTER_in_historyPredicateOperator512 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ON_in_historyPredicateOperator519 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DURING_in_historyPredicateOperator527 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQUALS_in_operator548 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_EQUALS_in_operator555 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LIKE_in_operator562 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_LIKE_in_operator569 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_operator577 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GT_in_operator584 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LTEQ_in_operator591 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GTEQ_in_operator598 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IN_in_operator605 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IS_in_operator612 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _NOT_in_operator614 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IS_in_operator621 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_operator628 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _IN_in_operator630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WAS_in_operator637 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WAS_in_operator644 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _NOT_in_operator646 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WAS_in_operator656 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _IN_in_operator658 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WAS_in_operator668 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _NOT_in_operator670 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _IN_in_operator672 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHANGED_in_operator682 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numberString_in_field746 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_field788 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _customField_in_field810 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _LBRACKET_in_field858 = new BitSet(new ulong[]{0xC14008000000000UL});
		public static readonly BitSet _argument_in_field896 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _RBRACKET_in_field928 = new BitSet(new ulong[]{0xC14008100000002UL});
		public static readonly BitSet _propertyArgument_in_field969 = new BitSet(new ulong[]{0xC14008100000002UL});
		public static readonly BitSet _CUSTOMFIELD_in_customField1039 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _LBRACKET_in_customField1041 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _POSNUMBER_in_customField1047 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _RBRACKET_in_customField1049 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _field_in_fieldCheck1091 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_fieldCheck1095 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EMPTY_in_operand1112 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_operand1123 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numberString_in_operand1134 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _func_in_operand1145 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _list_in_operand1156 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_string1196 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _QUOTE_STRING_in_string1207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SQUOTE_STRING_in_string1218 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_numberString1239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_stringValueCheck1270 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_stringValueCheck1274 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_list1304 = new BitSet(new ulong[]{0xC14008400200000UL});
		public static readonly BitSet _operand_in_list1310 = new BitSet(new ulong[]{0x80000000004000UL});
		public static readonly BitSet _COMMA_in_list1318 = new BitSet(new ulong[]{0xC14008400200000UL});
		public static readonly BitSet _operand_in_list1324 = new BitSet(new ulong[]{0x80000000004000UL});
		public static readonly BitSet _RPAREN_in_list1330 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcName_in_func1368 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _LPAREN_in_func1370 = new BitSet(new ulong[]{0xC94008000000000UL});
		public static readonly BitSet _arglist_in_func1372 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _RPAREN_in_func1375 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_funcName1412 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numberString_in_funcName1423 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcName_in_funcNameCheck1449 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_funcNameCheck1453 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _argument_in_arglist1486 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _COMMA_in_arglist1492 = new BitSet(new ulong[]{0xC14008000000000UL});
		public static readonly BitSet _argument_in_arglist1498 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _argument_in_propertyArgument1522 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_argument1544 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numberString_in_argument1556 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _argument_in_argumentCheck1589 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_argumentCheck1593 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ORDER_in_orderBy1617 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _BY_in_orderBy1619 = new BitSet(new ulong[]{0xC14008000020000UL});
		public static readonly BitSet _searchSort_in_orderBy1625 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _COMMA_in_orderBy1632 = new BitSet(new ulong[]{0xC14008000020000UL});
		public static readonly BitSet _searchSort_in_orderBy1638 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _field_in_searchSort1681 = new BitSet(new ulong[]{0x40102UL});
		public static readonly BitSet _DESC_in_searchSort1688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASC_in_searchSort1696 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  QuoteFlow.Models.Search.Jql.AntlrGen 
