//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 ../../QuoteFlow/Models/Search/Jql/Jql.g 2014-10-20 21:17:56

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;
using System.Collections.Generic;
using System.Linq;
using Antlr.Runtime;
using QuoteFlow.Infrastructure.Exceptions.Antlr;
using QuoteFlow.Infrastructure.Helpers;
using QuoteFlow.Models.Search.Jql.Parser;
using QuoteFlow.Models.Search.Jql.Util;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  QuoteFlow.Models.Search.Jql.AntlrGen 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class JqlLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int AFTER=4;
	public const int AMPER=5;
	public const int AMPER_AMPER=6;
	public const int AND=7;
	public const int ASC=8;
	public const int BANG=9;
	public const int BEFORE=10;
	public const int BSLASH=11;
	public const int BY=12;
	public const int CHANGED=13;
	public const int COMMA=14;
	public const int CONTROLCHARS=15;
	public const int CR=16;
	public const int CUSTOMFIELD=17;
	public const int DESC=18;
	public const int DIGIT=19;
	public const int DURING=20;
	public const int EMPTY=21;
	public const int EQUALS=22;
	public const int ERRORCHAR=23;
	public const int ERROR_RESERVED=24;
	public const int ESCAPE=25;
	public const int FROM=26;
	public const int GT=27;
	public const int GTEQ=28;
	public const int HEXDIGIT=29;
	public const int IN=30;
	public const int IS=31;
	public const int LBRACKET=32;
	public const int LIKE=33;
	public const int LPAREN=34;
	public const int LT=35;
	public const int LTEQ=36;
	public const int MATCHWS=37;
	public const int MINUS=38;
	public const int NEGNUMBER=39;
	public const int NEWLINE=40;
	public const int NL=41;
	public const int NOT=42;
	public const int NOT_EQUALS=43;
	public const int NOT_LIKE=44;
	public const int ON=45;
	public const int OR=46;
	public const int ORDER=47;
	public const int PIPE=48;
	public const int PIPE_PIPE=49;
	public const int POSNUMBER=50;
	public const int QUOTE=51;
	public const int QUOTE_STRING=52;
	public const int RBRACKET=53;
	public const int RESERVED_CHARS=54;
	public const int RPAREN=55;
	public const int SPACE=56;
	public const int SQUOTE=57;
	public const int SQUOTE_STRING=58;
	public const int STRING=59;
	public const int STRINGSTOP=60;
	public const int TO=61;
	public const int WAS=62;
	public const int WS=63;

		private LinkedList<AntlrPosition> Stack { get; set; }

	    private void StripAndSet()
	    {
	        string text = Text;
	        text = text.Substring(1, text.Length - 1 - 1);
	        text = JqlStringSupport.Decode(text);
	        Text = text;
	    }

	    private void CheckAndSet()
	    {
	        string text = JqlStringSupport.Decode(Text);
	        if (JqlStringSupport.IsReservedString(text))
	        {
	            var message = JqlParseErrorMessages.ReservedWord(text, state.tokenStartLine, state.tokenStartCharPositionInLine);
	            throw new RuntimeRecognitionException(message);
	        }
	        Text = text;
	    }

	    public override void EmitErrorMessage(string msg)
	    {
	        base.EmitErrorMessage(msg);
	    }

	    /// <summary>
	    /// START HACK 
	    /// We need to get the "lexer" to fail when it detects errors. At the moment ANTLR just drops the input
	    /// up until the error and tries again. This can leave antlr actually parsing JQL strings that are not
	    /// valid. For example, the string "priority = \kbjb" will actually be parsed as "priority = bjb". 
	    /// To stop this we throw a RuntimeRecognitionRuntimeException which the DefaultJqlParser is careful to catch. 
	    /// Throwing the RecognitionException  will not work as JqlLexer.nextToken catches this exception and tries 
	    /// again (which will cause an infinite loop).
	    /// 
	    /// Antlr (check up to 3.1.3) does not seem to be able to handle the "catch" clause on lexer rules. It throws a RuntimeException
	    /// when trying to process the grammar. To get around this we have hacked the error reporting using a "stack" to push
	    /// on the rule we currently have an error in. We can use this information to produce a pretty good error message when
	    /// the lexer tries to recover though is does make for some pretty strange logic.
	    /// </summary>
	    /// <param name="re"></param>
	    public override void Recover(RecognitionException re)
	    {
	        var handler = new LexerErrorHelper(input, PeekPosition());
	        handler.HandleError(re);
	    }

	    private void Recover()
	    {
	        var e = new MismatchedSetException(null, input);
	        Recover(e);
	    }

	    private void PushPosition(int tokenType)
	    {
	        Stack.AddLast(new AntlrPosition(tokenType, input));
	    }

	    private void PopPosition()
	    {
	        if (Stack.Count != 0) Stack.RemoveFirst();
	    }

	    private AntlrPosition PeekPosition()
	    {
	        return Stack.Count == 0 ? null : Stack.ElementAt(0);
	    }

	    public override void mTokens()
	    {
	    }


	// delegates
	// delegators

	public JqlLexer()
	{
		OnCreated();
	}

	public JqlLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public JqlLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "../../QuoteFlow/Models/Search/Jql/Jql.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 1);
		TraceIn("LPAREN", 1);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:902:13: ( '(' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:902:16: '('
			{
			DebugLocation(902, 16);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 1);
			LeaveRule("LPAREN", 1);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 2);
		TraceIn("RPAREN", 2);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:900:9: ( ')' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:900:11: ')'
			{
			DebugLocation(900, 11);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 2);
			LeaveRule("RPAREN", 2);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_COMMA();
	partial void LeaveRule_COMMA();

	// $ANTLR start "COMMA"
	[GrammarRule("COMMA")]
	private void mCOMMA()
	{
		EnterRule_COMMA();
		EnterRule("COMMA", 3);
		TraceIn("COMMA", 3);
		try
		{
			int _type = COMMA;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:901:8: ( ',' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:901:11: ','
			{
			DebugLocation(901, 11);
			Match(','); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMA", 3);
			LeaveRule("COMMA", 3);
			LeaveRule_COMMA();
		}
	}
	// $ANTLR end "COMMA"

	partial void EnterRule_LBRACKET();
	partial void LeaveRule_LBRACKET();

	// $ANTLR start "LBRACKET"
	[GrammarRule("LBRACKET")]
	private void mLBRACKET()
	{
		EnterRule_LBRACKET();
		EnterRule("LBRACKET", 4);
		TraceIn("LBRACKET", 4);
		try
		{
			int _type = LBRACKET;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:902:10: ( '[' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:902:12: '['
			{
			DebugLocation(902, 12);
			Match('['); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LBRACKET", 4);
			LeaveRule("LBRACKET", 4);
			LeaveRule_LBRACKET();
		}
	}
	// $ANTLR end "LBRACKET"

	partial void EnterRule_RBRACKET();
	partial void LeaveRule_RBRACKET();

	// $ANTLR start "RBRACKET"
	[GrammarRule("RBRACKET")]
	private void mRBRACKET()
	{
		EnterRule_RBRACKET();
		EnterRule("RBRACKET", 5);
		TraceIn("RBRACKET", 5);
		try
		{
			int _type = RBRACKET;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:903:11: ( ']' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:903:14: ']'
			{
			DebugLocation(903, 14);
			Match(']'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RBRACKET", 5);
			LeaveRule("RBRACKET", 5);
			LeaveRule_RBRACKET();
		}
	}
	// $ANTLR end "RBRACKET"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 6);
		TraceIn("MINUS", 6);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:905:15: ( '-' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:905:18: '-'
			{
			DebugLocation(905, 18);
			Match('-'); 

			}

		}
		finally
		{
			TraceOut("MINUS", 6);
			LeaveRule("MINUS", 6);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_BANG();
	partial void LeaveRule_BANG();

	// $ANTLR start "BANG"
	[GrammarRule("BANG")]
	private void mBANG()
	{
		EnterRule_BANG();
		EnterRule("BANG", 7);
		TraceIn("BANG", 7);
		try
		{
			int _type = BANG;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:915:7: ( '!' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:915:9: '!'
			{
			DebugLocation(915, 9);
			Match('!'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BANG", 7);
			LeaveRule("BANG", 7);
			LeaveRule_BANG();
		}
	}
	// $ANTLR end "BANG"

	partial void EnterRule_LT();
	partial void LeaveRule_LT();

	// $ANTLR start "LT"
	[GrammarRule("LT")]
	private void mLT()
	{
		EnterRule_LT();
		EnterRule("LT", 8);
		TraceIn("LT", 8);
		try
		{
			int _type = LT;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:912:5: ( '<' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:912:7: '<'
			{
			DebugLocation(912, 7);
			Match('<'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LT", 8);
			LeaveRule("LT", 8);
			LeaveRule_LT();
		}
	}
	// $ANTLR end "LT"

	partial void EnterRule_GT();
	partial void LeaveRule_GT();

	// $ANTLR start "GT"
	[GrammarRule("GT")]
	private void mGT()
	{
		EnterRule_GT();
		EnterRule("GT", 9);
		TraceIn("GT", 9);
		try
		{
			int _type = GT;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:913:5: ( '>' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:913:7: '>'
			{
			DebugLocation(913, 7);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GT", 9);
			LeaveRule("GT", 9);
			LeaveRule_GT();
		}
	}
	// $ANTLR end "GT"

	partial void EnterRule_GTEQ();
	partial void LeaveRule_GTEQ();

	// $ANTLR start "GTEQ"
	[GrammarRule("GTEQ")]
	private void mGTEQ()
	{
		EnterRule_GTEQ();
		EnterRule("GTEQ", 10);
		TraceIn("GTEQ", 10);
		try
		{
			int _type = GTEQ;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:914:7: ( '>=' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:914:9: '>='
			{
			DebugLocation(914, 9);
			Match(">="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GTEQ", 10);
			LeaveRule("GTEQ", 10);
			LeaveRule_GTEQ();
		}
	}
	// $ANTLR end "GTEQ"

	partial void EnterRule_LTEQ();
	partial void LeaveRule_LTEQ();

	// $ANTLR start "LTEQ"
	[GrammarRule("LTEQ")]
	private void mLTEQ()
	{
		EnterRule_LTEQ();
		EnterRule("LTEQ", 11);
		TraceIn("LTEQ", 11);
		try
		{
			int _type = LTEQ;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:915:8: ( '<=' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:915:10: '<='
			{
			DebugLocation(915, 10);
			Match("<="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LTEQ", 11);
			LeaveRule("LTEQ", 11);
			LeaveRule_LTEQ();
		}
	}
	// $ANTLR end "LTEQ"

	partial void EnterRule_EQUALS();
	partial void LeaveRule_EQUALS();

	// $ANTLR start "EQUALS"
	[GrammarRule("EQUALS")]
	private void mEQUALS()
	{
		EnterRule_EQUALS();
		EnterRule("EQUALS", 12);
		TraceIn("EQUALS", 12);
		try
		{
			int _type = EQUALS;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:916:9: ( '=' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:916:11: '='
			{
			DebugLocation(916, 11);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQUALS", 12);
			LeaveRule("EQUALS", 12);
			LeaveRule_EQUALS();
		}
	}
	// $ANTLR end "EQUALS"

	partial void EnterRule_NOT_EQUALS();
	partial void LeaveRule_NOT_EQUALS();

	// $ANTLR start "NOT_EQUALS"
	[GrammarRule("NOT_EQUALS")]
	private void mNOT_EQUALS()
	{
		EnterRule_NOT_EQUALS();
		EnterRule("NOT_EQUALS", 13);
		TraceIn("NOT_EQUALS", 13);
		try
		{
			int _type = NOT_EQUALS;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:917:12: ( '!=' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:917:14: '!='
			{
			DebugLocation(917, 14);
			Match("!="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT_EQUALS", 13);
			LeaveRule("NOT_EQUALS", 13);
			LeaveRule_NOT_EQUALS();
		}
	}
	// $ANTLR end "NOT_EQUALS"

	partial void EnterRule_LIKE();
	partial void LeaveRule_LIKE();

	// $ANTLR start "LIKE"
	[GrammarRule("LIKE")]
	private void mLIKE()
	{
		EnterRule_LIKE();
		EnterRule("LIKE", 14);
		TraceIn("LIKE", 14);
		try
		{
			int _type = LIKE;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:918:7: ( '~' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:918:9: '~'
			{
			DebugLocation(918, 9);
			Match('~'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LIKE", 14);
			LeaveRule("LIKE", 14);
			LeaveRule_LIKE();
		}
	}
	// $ANTLR end "LIKE"

	partial void EnterRule_NOT_LIKE();
	partial void LeaveRule_NOT_LIKE();

	// $ANTLR start "NOT_LIKE"
	[GrammarRule("NOT_LIKE")]
	private void mNOT_LIKE()
	{
		EnterRule_NOT_LIKE();
		EnterRule("NOT_LIKE", 15);
		TraceIn("NOT_LIKE", 15);
		try
		{
			int _type = NOT_LIKE;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:919:10: ( '!~' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:919:12: '!~'
			{
			DebugLocation(919, 12);
			Match("!~"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT_LIKE", 15);
			LeaveRule("NOT_LIKE", 15);
			LeaveRule_NOT_LIKE();
		}
	}
	// $ANTLR end "NOT_LIKE"

	partial void EnterRule_IN();
	partial void LeaveRule_IN();

	// $ANTLR start "IN"
	[GrammarRule("IN")]
	private void mIN()
	{
		EnterRule_IN();
		EnterRule("IN", 16);
		TraceIn("IN", 16);
		try
		{
			int _type = IN;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:920:5: ( ( 'I' | 'i' ) ( 'N' | 'n' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:920:7: ( 'I' | 'i' ) ( 'N' | 'n' )
			{
			DebugLocation(920, 7);
			if (input.LA(1)=='I'||input.LA(1)=='i')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(920, 16);
			if (input.LA(1)=='N'||input.LA(1)=='n')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IN", 16);
			LeaveRule("IN", 16);
			LeaveRule_IN();
		}
	}
	// $ANTLR end "IN"

	partial void EnterRule_IS();
	partial void LeaveRule_IS();

	// $ANTLR start "IS"
	[GrammarRule("IS")]
	private void mIS()
	{
		EnterRule_IS();
		EnterRule("IS", 17);
		TraceIn("IS", 17);
		try
		{
			int _type = IS;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:921:5: ( ( 'I' | 'i' ) ( 'S' | 's' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:921:7: ( 'I' | 'i' ) ( 'S' | 's' )
			{
			DebugLocation(921, 7);
			if (input.LA(1)=='I'||input.LA(1)=='i')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(921, 16);
			if (input.LA(1)=='S'||input.LA(1)=='s')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IS", 17);
			LeaveRule("IS", 17);
			LeaveRule_IS();
		}
	}
	// $ANTLR end "IS"

	partial void EnterRule_AND();
	partial void LeaveRule_AND();

	// $ANTLR start "AND"
	[GrammarRule("AND")]
	private void mAND()
	{
		EnterRule_AND();
		EnterRule("AND", 18);
		TraceIn("AND", 18);
		try
		{
			int _type = AND;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:922:7: ( ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'D' | 'd' ) | AMPER | AMPER_AMPER )
			int alt1=3;
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1=='A'||LA1_1=='a'))
			{
				alt1 = 1;
			}
			else if ((LA1_1=='&'))
			{
				int LA1_2 = input.LA(2);

				if ((LA1_2=='&'))
				{
					alt1 = 3;
				}
				else
				{
					alt1 = 2;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:922:9: ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'D' | 'd' )
				{
				DebugLocation(922, 9);
				input.Consume();

				DebugLocation(922, 18);
				input.Consume();

				DebugLocation(922, 27);
				input.Consume();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:922:39: AMPER
				{
				DebugLocation(922, 39);
				mAMPER(); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:922:47: AMPER_AMPER
				{
				DebugLocation(922, 47);
				mAMPER_AMPER(); 

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AND", 18);
			LeaveRule("AND", 18);
			LeaveRule_AND();
		}
	}
	// $ANTLR end "AND"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 19);
		TraceIn("OR", 19);
		try
		{
			int _type = OR;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:923:5: ( ( 'O' | 'o' ) ( 'R' | 'r' ) | PIPE | PIPE_PIPE )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1=='O'||LA2_1=='o'))
			{
				alt2 = 1;
			}
			else if ((LA2_1=='|'))
			{
				int LA2_2 = input.LA(2);

				if ((LA2_2=='|'))
				{
					alt2 = 3;
				}
				else
				{
					alt2 = 2;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:923:7: ( 'O' | 'o' ) ( 'R' | 'r' )
				{
				DebugLocation(923, 7);
				input.Consume();

				DebugLocation(923, 16);
				input.Consume();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:923:28: PIPE
				{
				DebugLocation(923, 28);
				mPIPE(); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:923:35: PIPE_PIPE
				{
				DebugLocation(923, 35);
				mPIPE_PIPE(); 

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OR", 19);
			LeaveRule("OR", 19);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_NOT();
	partial void LeaveRule_NOT();

	// $ANTLR start "NOT"
	[GrammarRule("NOT")]
	private void mNOT()
	{
		EnterRule_NOT();
		EnterRule("NOT", 20);
		TraceIn("NOT", 20);
		try
		{
			int _type = NOT;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:924:6: ( ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'T' | 't' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:924:8: ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'T' | 't' )
			{
			DebugLocation(924, 8);
			if (input.LA(1)=='N'||input.LA(1)=='n')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(924, 17);
			if (input.LA(1)=='O'||input.LA(1)=='o')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(924, 26);
			if (input.LA(1)=='T'||input.LA(1)=='t')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT", 20);
			LeaveRule("NOT", 20);
			LeaveRule_NOT();
		}
	}
	// $ANTLR end "NOT"

	partial void EnterRule_EMPTY();
	partial void LeaveRule_EMPTY();

	// $ANTLR start "EMPTY"
	[GrammarRule("EMPTY")]
	private void mEMPTY()
	{
		EnterRule_EMPTY();
		EnterRule("EMPTY", 21);
		TraceIn("EMPTY", 21);
		try
		{
			int _type = EMPTY;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:925:8: ( ( 'E' | 'e' ) ( 'M' | 'm' ) ( 'P' | 'p' ) ( 'T' | 't' ) ( 'Y' | 'y' ) | ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'L' | 'l' ) ( 'L' | 'l' ) )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1=='E'||LA3_1=='e'))
			{
				alt3 = 1;
			}
			else if ((LA3_1=='N'||LA3_1=='n'))
			{
				alt3 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:925:10: ( 'E' | 'e' ) ( 'M' | 'm' ) ( 'P' | 'p' ) ( 'T' | 't' ) ( 'Y' | 'y' )
				{
				DebugLocation(925, 10);
				input.Consume();

				DebugLocation(925, 19);
				input.Consume();

				DebugLocation(925, 28);
				input.Consume();

				DebugLocation(925, 37);
				input.Consume();

				DebugLocation(925, 46);
				input.Consume();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:925:58: ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'L' | 'l' ) ( 'L' | 'l' )
				{
				DebugLocation(925, 58);
				input.Consume();

				DebugLocation(925, 67);
				input.Consume();

				DebugLocation(925, 76);
				input.Consume();

				DebugLocation(925, 85);
				input.Consume();


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EMPTY", 21);
			LeaveRule("EMPTY", 21);
			LeaveRule_EMPTY();
		}
	}
	// $ANTLR end "EMPTY"

	partial void EnterRule_WAS();
	partial void LeaveRule_WAS();

	// $ANTLR start "WAS"
	[GrammarRule("WAS")]
	private void mWAS()
	{
		EnterRule_WAS();
		EnterRule("WAS", 22);
		TraceIn("WAS", 22);
		try
		{
			int _type = WAS;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:927:6: ( ( 'W' | 'w' ) ( 'A' | 'a' ) ( 'S' | 's' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:927:8: ( 'W' | 'w' ) ( 'A' | 'a' ) ( 'S' | 's' )
			{
			DebugLocation(927, 8);
			if (input.LA(1)=='W'||input.LA(1)=='w')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(927, 17);
			if (input.LA(1)=='A'||input.LA(1)=='a')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(927, 26);
			if (input.LA(1)=='S'||input.LA(1)=='s')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WAS", 22);
			LeaveRule("WAS", 22);
			LeaveRule_WAS();
		}
	}
	// $ANTLR end "WAS"

	partial void EnterRule_CHANGED();
	partial void LeaveRule_CHANGED();

	// $ANTLR start "CHANGED"
	[GrammarRule("CHANGED")]
	private void mCHANGED()
	{
		EnterRule_CHANGED();
		EnterRule("CHANGED", 23);
		TraceIn("CHANGED", 23);
		try
		{
			int _type = CHANGED;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:928:10: ( ( 'C' | 'c' ) ( 'H' | 'h' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' ) ( 'E' | 'e' ) ( 'D' | 'd' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:928:12: ( 'C' | 'c' ) ( 'H' | 'h' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' ) ( 'E' | 'e' ) ( 'D' | 'd' )
			{
			DebugLocation(928, 12);
			if (input.LA(1)=='C'||input.LA(1)=='c')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(928, 21);
			if (input.LA(1)=='H'||input.LA(1)=='h')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(928, 30);
			if (input.LA(1)=='A'||input.LA(1)=='a')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(928, 39);
			if (input.LA(1)=='N'||input.LA(1)=='n')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(928, 48);
			if (input.LA(1)=='G'||input.LA(1)=='g')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(928, 57);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(928, 66);
			if (input.LA(1)=='D'||input.LA(1)=='d')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CHANGED", 23);
			LeaveRule("CHANGED", 23);
			LeaveRule_CHANGED();
		}
	}
	// $ANTLR end "CHANGED"

	partial void EnterRule_BEFORE();
	partial void LeaveRule_BEFORE();

	// $ANTLR start "BEFORE"
	[GrammarRule("BEFORE")]
	private void mBEFORE()
	{
		EnterRule_BEFORE();
		EnterRule("BEFORE", 24);
		TraceIn("BEFORE", 24);
		try
		{
			int _type = BEFORE;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:930:9: ( ( 'B' | 'b' ) ( 'E' | 'e' ) ( 'F' | 'f' ) ( 'O' | 'o' ) ( 'R' | 'r' ) ( 'E' | 'e' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:930:11: ( 'B' | 'b' ) ( 'E' | 'e' ) ( 'F' | 'f' ) ( 'O' | 'o' ) ( 'R' | 'r' ) ( 'E' | 'e' )
			{
			DebugLocation(930, 11);
			if (input.LA(1)=='B'||input.LA(1)=='b')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(930, 20);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(930, 29);
			if (input.LA(1)=='F'||input.LA(1)=='f')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(930, 38);
			if (input.LA(1)=='O'||input.LA(1)=='o')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(930, 47);
			if (input.LA(1)=='R'||input.LA(1)=='r')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(930, 56);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BEFORE", 24);
			LeaveRule("BEFORE", 24);
			LeaveRule_BEFORE();
		}
	}
	// $ANTLR end "BEFORE"

	partial void EnterRule_AFTER();
	partial void LeaveRule_AFTER();

	// $ANTLR start "AFTER"
	[GrammarRule("AFTER")]
	private void mAFTER()
	{
		EnterRule_AFTER();
		EnterRule("AFTER", 25);
		TraceIn("AFTER", 25);
		try
		{
			int _type = AFTER;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:931:8: ( ( 'A' | 'a' ) ( 'F' | 'f' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:931:10: ( 'A' | 'a' ) ( 'F' | 'f' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' )
			{
			DebugLocation(931, 10);
			if (input.LA(1)=='A'||input.LA(1)=='a')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(931, 19);
			if (input.LA(1)=='F'||input.LA(1)=='f')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(931, 28);
			if (input.LA(1)=='T'||input.LA(1)=='t')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(931, 37);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(931, 46);
			if (input.LA(1)=='R'||input.LA(1)=='r')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AFTER", 25);
			LeaveRule("AFTER", 25);
			LeaveRule_AFTER();
		}
	}
	// $ANTLR end "AFTER"

	partial void EnterRule_FROM();
	partial void LeaveRule_FROM();

	// $ANTLR start "FROM"
	[GrammarRule("FROM")]
	private void mFROM()
	{
		EnterRule_FROM();
		EnterRule("FROM", 26);
		TraceIn("FROM", 26);
		try
		{
			int _type = FROM;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:932:7: ( ( 'F' | 'f' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'M' | 'm' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:932:9: ( 'F' | 'f' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'M' | 'm' )
			{
			DebugLocation(932, 9);
			if (input.LA(1)=='F'||input.LA(1)=='f')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(932, 18);
			if (input.LA(1)=='R'||input.LA(1)=='r')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(932, 27);
			if (input.LA(1)=='O'||input.LA(1)=='o')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(932, 36);
			if (input.LA(1)=='M'||input.LA(1)=='m')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FROM", 26);
			LeaveRule("FROM", 26);
			LeaveRule_FROM();
		}
	}
	// $ANTLR end "FROM"

	partial void EnterRule_TO();
	partial void LeaveRule_TO();

	// $ANTLR start "TO"
	[GrammarRule("TO")]
	private void mTO()
	{
		EnterRule_TO();
		EnterRule("TO", 27);
		TraceIn("TO", 27);
		try
		{
			int _type = TO;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:933:5: ( ( 'T' | 't' ) ( 'O' | 'o' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:933:7: ( 'T' | 't' ) ( 'O' | 'o' )
			{
			DebugLocation(933, 7);
			if (input.LA(1)=='T'||input.LA(1)=='t')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(933, 16);
			if (input.LA(1)=='O'||input.LA(1)=='o')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TO", 27);
			LeaveRule("TO", 27);
			LeaveRule_TO();
		}
	}
	// $ANTLR end "TO"

	partial void EnterRule_ON();
	partial void LeaveRule_ON();

	// $ANTLR start "ON"
	[GrammarRule("ON")]
	private void mON()
	{
		EnterRule_ON();
		EnterRule("ON", 28);
		TraceIn("ON", 28);
		try
		{
			int _type = ON;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:936:5: ( ( 'O' | 'o' ) ( 'N' | 'n' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:936:7: ( 'O' | 'o' ) ( 'N' | 'n' )
			{
			DebugLocation(936, 7);
			if (input.LA(1)=='O'||input.LA(1)=='o')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(936, 16);
			if (input.LA(1)=='N'||input.LA(1)=='n')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ON", 28);
			LeaveRule("ON", 28);
			LeaveRule_ON();
		}
	}
	// $ANTLR end "ON"

	partial void EnterRule_DURING();
	partial void LeaveRule_DURING();

	// $ANTLR start "DURING"
	[GrammarRule("DURING")]
	private void mDURING()
	{
		EnterRule_DURING();
		EnterRule("DURING", 29);
		TraceIn("DURING", 29);
		try
		{
			int _type = DURING;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:937:9: ( ( 'D' | 'd' ) ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:937:11: ( 'D' | 'd' ) ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' )
			{
			DebugLocation(937, 11);
			if (input.LA(1)=='D'||input.LA(1)=='d')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(937, 20);
			if (input.LA(1)=='U'||input.LA(1)=='u')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(937, 29);
			if (input.LA(1)=='R'||input.LA(1)=='r')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(937, 38);
			if (input.LA(1)=='I'||input.LA(1)=='i')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(937, 47);
			if (input.LA(1)=='N'||input.LA(1)=='n')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(937, 56);
			if (input.LA(1)=='G'||input.LA(1)=='g')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DURING", 29);
			LeaveRule("DURING", 29);
			LeaveRule_DURING();
		}
	}
	// $ANTLR end "DURING"

	partial void EnterRule_ORDER();
	partial void LeaveRule_ORDER();

	// $ANTLR start "ORDER"
	[GrammarRule("ORDER")]
	private void mORDER()
	{
		EnterRule_ORDER();
		EnterRule("ORDER", 30);
		TraceIn("ORDER", 30);
		try
		{
			int _type = ORDER;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:946:7: ( ( 'o' | 'O' ) ( 'r' | 'R' ) ( 'd' | 'D' ) ( 'e' | 'E' ) ( 'r' | 'R' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:946:9: ( 'o' | 'O' ) ( 'r' | 'R' ) ( 'd' | 'D' ) ( 'e' | 'E' ) ( 'r' | 'R' )
			{
			DebugLocation(946, 9);
			if (input.LA(1)=='O'||input.LA(1)=='o')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(946, 18);
			if (input.LA(1)=='R'||input.LA(1)=='r')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(946, 27);
			if (input.LA(1)=='D'||input.LA(1)=='d')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(946, 36);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(946, 45);
			if (input.LA(1)=='R'||input.LA(1)=='r')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ORDER", 30);
			LeaveRule("ORDER", 30);
			LeaveRule_ORDER();
		}
	}
	// $ANTLR end "ORDER"

	partial void EnterRule_BY();
	partial void LeaveRule_BY();

	// $ANTLR start "BY"
	[GrammarRule("BY")]
	private void mBY()
	{
		EnterRule_BY();
		EnterRule("BY", 31);
		TraceIn("BY", 31);
		try
		{
			int _type = BY;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:944:4: ( ( 'b' | 'B' ) ( 'y' | 'Y' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:944:6: ( 'b' | 'B' ) ( 'y' | 'Y' )
			{
			DebugLocation(944, 6);
			if (input.LA(1)=='B'||input.LA(1)=='b')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(944, 15);
			if (input.LA(1)=='Y'||input.LA(1)=='y')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BY", 31);
			LeaveRule("BY", 31);
			LeaveRule_BY();
		}
	}
	// $ANTLR end "BY"

	partial void EnterRule_ASC();
	partial void LeaveRule_ASC();

	// $ANTLR start "ASC"
	[GrammarRule("ASC")]
	private void mASC()
	{
		EnterRule_ASC();
		EnterRule("ASC", 32);
		TraceIn("ASC", 32);
		try
		{
			int _type = ASC;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:945:5: ( ( 'a' | 'A' ) ( 's' | 'S' ) ( 'c' | 'C' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:945:7: ( 'a' | 'A' ) ( 's' | 'S' ) ( 'c' | 'C' )
			{
			DebugLocation(945, 7);
			if (input.LA(1)=='A'||input.LA(1)=='a')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(945, 16);
			if (input.LA(1)=='S'||input.LA(1)=='s')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(945, 25);
			if (input.LA(1)=='C'||input.LA(1)=='c')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASC", 32);
			LeaveRule("ASC", 32);
			LeaveRule_ASC();
		}
	}
	// $ANTLR end "ASC"

	partial void EnterRule_DESC();
	partial void LeaveRule_DESC();

	// $ANTLR start "DESC"
	[GrammarRule("DESC")]
	private void mDESC()
	{
		EnterRule_DESC();
		EnterRule("DESC", 33);
		TraceIn("DESC", 33);
		try
		{
			int _type = DESC;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:946:5: ( ( 'd' | 'D' ) ( 'e' | 'E' ) ( 's' | 'S' ) ( 'c' | 'C' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:946:7: ( 'd' | 'D' ) ( 'e' | 'E' ) ( 's' | 'S' ) ( 'c' | 'C' )
			{
			DebugLocation(946, 7);
			if (input.LA(1)=='D'||input.LA(1)=='d')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(946, 16);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(946, 25);
			if (input.LA(1)=='S'||input.LA(1)=='s')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(946, 34);
			if (input.LA(1)=='C'||input.LA(1)=='c')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DESC", 33);
			LeaveRule("DESC", 33);
			LeaveRule_DESC();
		}
	}
	// $ANTLR end "DESC"

	partial void EnterRule_POSNUMBER();
	partial void LeaveRule_POSNUMBER();

	// $ANTLR start "POSNUMBER"
	[GrammarRule("POSNUMBER")]
	private void mPOSNUMBER()
	{
		EnterRule_POSNUMBER();
		EnterRule("POSNUMBER", 34);
		TraceIn("POSNUMBER", 34);
		try
		{
			int _type = POSNUMBER;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:952:2: ( ( DIGIT )+ )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:952:4: ( DIGIT )+
			{
			DebugLocation(952, 4);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:952:4: ( DIGIT )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if (((LA4_1>='0' && LA4_1<='9')))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// ../../QuoteFlow/Models/Search/Jql/Jql.g:
					{
					DebugLocation(952, 4);
					input.Consume();


					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("POSNUMBER", 34);
			LeaveRule("POSNUMBER", 34);
			LeaveRule_POSNUMBER();
		}
	}
	// $ANTLR end "POSNUMBER"

	partial void EnterRule_NEGNUMBER();
	partial void LeaveRule_NEGNUMBER();

	// $ANTLR start "NEGNUMBER"
	[GrammarRule("NEGNUMBER")]
	private void mNEGNUMBER()
	{
		EnterRule_NEGNUMBER();
		EnterRule("NEGNUMBER", 35);
		TraceIn("NEGNUMBER", 35);
		try
		{
			int _type = NEGNUMBER;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:955:2: ( MINUS ( DIGIT )+ )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:955:4: MINUS ( DIGIT )+
			{
			DebugLocation(955, 4);
			mMINUS(); 
			DebugLocation(955, 10);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:955:10: ( DIGIT )+
			int cnt5=0;
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if (((LA5_1>='0' && LA5_1<='9')))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch (alt5)
				{
				case 1:
					DebugEnterAlt(1);
					// ../../QuoteFlow/Models/Search/Jql/Jql.g:
					{
					DebugLocation(955, 10);
					input.Consume();


					}
					break;

				default:
					if (cnt5 >= 1)
						goto loop5;

					EarlyExitException eee5 = new EarlyExitException( 5, input );
					DebugRecognitionException(eee5);
					throw eee5;
				}
				cnt5++;
			}
			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEGNUMBER", 35);
			LeaveRule("NEGNUMBER", 35);
			LeaveRule_NEGNUMBER();
		}
	}
	// $ANTLR end "NEGNUMBER"

	partial void EnterRule_CUSTOMFIELD();
	partial void LeaveRule_CUSTOMFIELD();

	// $ANTLR start "CUSTOMFIELD"
	[GrammarRule("CUSTOMFIELD")]
	private void mCUSTOMFIELD()
	{
		EnterRule_CUSTOMFIELD();
		EnterRule("CUSTOMFIELD", 36);
		TraceIn("CUSTOMFIELD", 36);
		try
		{
			int _type = CUSTOMFIELD;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:964:2: ( ( 'c' | 'C' ) ( 'f' | 'F' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:964:4: ( 'c' | 'C' ) ( 'f' | 'F' )
			{
			DebugLocation(964, 4);
			if (input.LA(1)=='C'||input.LA(1)=='c')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(964, 13);
			if (input.LA(1)=='F'||input.LA(1)=='f')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CUSTOMFIELD", 36);
			LeaveRule("CUSTOMFIELD", 36);
			LeaveRule_CUSTOMFIELD();
		}
	}
	// $ANTLR end "CUSTOMFIELD"

	partial void EnterRule_STRING();
	partial void LeaveRule_STRING();

	// $ANTLR start "STRING"
	[GrammarRule("STRING")]
	private void mSTRING()
	{
		EnterRule_STRING();
		EnterRule("STRING", 37);
		TraceIn("STRING", 37);
		try
		{
			int _type = STRING;
			int _channel = DefaultTokenChannel;
			 pushPosition(STRING); 
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:974:2: ( ( ESCAPE |~ ( BSLASH | WS | STRINGSTOP ) )+ )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:974:4: ( ESCAPE |~ ( BSLASH | WS | STRINGSTOP ) )+
			{
			DebugLocation(974, 4);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:974:4: ( ESCAPE |~ ( BSLASH | WS | STRINGSTOP ) )+
			int cnt6=0;
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=3;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1=='\\'))
				{
					alt6 = 1;
				}
				else if (((LA6_1>='-' && LA6_1<='.')||(LA6_1>='0' && LA6_1<=':')||(LA6_1>='A' && LA6_1<='Z')||(LA6_1>='_' && LA6_1<='z')||(LA6_1>='\u00A0' && LA6_1<='\uFDCF')||(LA6_1>='\uFDF0' && LA6_1<='\uFFFD')))
				{
					alt6 = 2;
				}


				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// ../../QuoteFlow/Models/Search/Jql/Jql.g:974:5: ESCAPE
					{
					DebugLocation(974, 5);
					mESCAPE(); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ../../QuoteFlow/Models/Search/Jql/Jql.g:974:14: ~ ( BSLASH | WS | STRINGSTOP )
					{
					DebugLocation(974, 14);
					input.Consume();


					}
					break;

				default:
					if (cnt6 >= 1)
						goto loop6;

					EarlyExitException eee6 = new EarlyExitException( 6, input );
					DebugRecognitionException(eee6);
					throw eee6;
				}
				cnt6++;
			}
			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(975, 2);

					// Once this method is called, the text of the current token is fixed. This means that this Lexical rule
					// should not be called from other lexical rules.
					checkAndSet();
				

			}

			state.type = _type;
			state.channel = _channel;
			 popPosition(); 
		}
		finally
		{
			TraceOut("STRING", 37);
			LeaveRule("STRING", 37);
			LeaveRule_STRING();
		}
	}
	// $ANTLR end "STRING"

	partial void EnterRule_QUOTE_STRING();
	partial void LeaveRule_QUOTE_STRING();

	// $ANTLR start "QUOTE_STRING"
	[GrammarRule("QUOTE_STRING")]
	private void mQUOTE_STRING()
	{
		EnterRule_QUOTE_STRING();
		EnterRule("QUOTE_STRING", 38);
		TraceIn("QUOTE_STRING", 38);
		try
		{
			int _type = QUOTE_STRING;
			int _channel = DefaultTokenChannel;
			 pushPosition(QUOTE_STRING); 
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:981:2: ( ( QUOTE ( ESCAPE |~ ( BSLASH | QUOTE | CONTROLCHARS ) )* QUOTE ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:981:4: ( QUOTE ( ESCAPE |~ ( BSLASH | QUOTE | CONTROLCHARS ) )* QUOTE )
			{
			DebugLocation(981, 4);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:981:4: ( QUOTE ( ESCAPE |~ ( BSLASH | QUOTE | CONTROLCHARS ) )* QUOTE )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:981:5: QUOTE ( ESCAPE |~ ( BSLASH | QUOTE | CONTROLCHARS ) )* QUOTE
			{
			DebugLocation(981, 5);
			mQUOTE(); 
			DebugLocation(981, 11);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:981:11: ( ESCAPE |~ ( BSLASH | QUOTE | CONTROLCHARS ) )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=3;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1=='\\'))
				{
					alt7 = 1;
				}
				else if ((LA7_1=='\n'||LA7_1=='\r'||(LA7_1>=' ' && LA7_1<='!')||(LA7_1>='#' && LA7_1<='[')||(LA7_1>=']' && LA7_1<='~')||(LA7_1>='\u00A0' && LA7_1<='\uFDCF')||(LA7_1>='\uFDF0' && LA7_1<='\uFFFD')))
				{
					alt7 = 2;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// ../../QuoteFlow/Models/Search/Jql/Jql.g:981:12: ESCAPE
					{
					DebugLocation(981, 12);
					mESCAPE(); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ../../QuoteFlow/Models/Search/Jql/Jql.g:981:21: ~ ( BSLASH | QUOTE | CONTROLCHARS )
					{
					DebugLocation(981, 21);
					input.Consume();


					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(981, 56);
			mQUOTE(); 

			}

			DebugLocation(982, 2);

					//Once this method is called, the text of the current token is fixed. This means that this Lexical rule
					//should not be called from other lexical rules.
					stripAndSet();
				

			}

			state.type = _type;
			state.channel = _channel;
			 popPosition(); 
		}
		finally
		{
			TraceOut("QUOTE_STRING", 38);
			LeaveRule("QUOTE_STRING", 38);
			LeaveRule_QUOTE_STRING();
		}
	}
	// $ANTLR end "QUOTE_STRING"

	partial void EnterRule_SQUOTE_STRING();
	partial void LeaveRule_SQUOTE_STRING();

	// $ANTLR start "SQUOTE_STRING"
	[GrammarRule("SQUOTE_STRING")]
	private void mSQUOTE_STRING()
	{
		EnterRule_SQUOTE_STRING();
		EnterRule("SQUOTE_STRING", 39);
		TraceIn("SQUOTE_STRING", 39);
		try
		{
			int _type = SQUOTE_STRING;
			int _channel = DefaultTokenChannel;
			 pushPosition(SQUOTE_STRING); 
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:991:2: ( ( SQUOTE ( ESCAPE |~ ( BSLASH | SQUOTE | CONTROLCHARS ) )* SQUOTE ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:991:4: ( SQUOTE ( ESCAPE |~ ( BSLASH | SQUOTE | CONTROLCHARS ) )* SQUOTE )
			{
			DebugLocation(991, 4);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:991:4: ( SQUOTE ( ESCAPE |~ ( BSLASH | SQUOTE | CONTROLCHARS ) )* SQUOTE )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:991:5: SQUOTE ( ESCAPE |~ ( BSLASH | SQUOTE | CONTROLCHARS ) )* SQUOTE
			{
			DebugLocation(991, 5);
			mSQUOTE(); 
			DebugLocation(991, 12);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:991:12: ( ESCAPE |~ ( BSLASH | SQUOTE | CONTROLCHARS ) )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=3;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1=='\\'))
				{
					alt8 = 1;
				}
				else if ((LA8_1=='\n'||LA8_1=='\r'||(LA8_1>=' ' && LA8_1<='&')||(LA8_1>='(' && LA8_1<='[')||(LA8_1>=']' && LA8_1<='~')||(LA8_1>='\u00A0' && LA8_1<='\uFDCF')||(LA8_1>='\uFDF0' && LA8_1<='\uFFFD')))
				{
					alt8 = 2;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// ../../QuoteFlow/Models/Search/Jql/Jql.g:991:13: ESCAPE
					{
					DebugLocation(991, 13);
					mESCAPE(); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ../../QuoteFlow/Models/Search/Jql/Jql.g:991:22: ~ ( BSLASH | SQUOTE | CONTROLCHARS )
					{
					DebugLocation(991, 22);
					input.Consume();


					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(991, 58);
			mSQUOTE(); 

			}

			DebugLocation(992, 2);

					//Once this method is called, the text of the current token is fixed. This means that this Lexical rule
					//should not be called from other lexical rules.
					stripAndSet();
				

			}

			state.type = _type;
			state.channel = _channel;
			 popPosition(); 
		}
		finally
		{
			TraceOut("SQUOTE_STRING", 39);
			LeaveRule("SQUOTE_STRING", 39);
			LeaveRule_SQUOTE_STRING();
		}
	}
	// $ANTLR end "SQUOTE_STRING"

	partial void EnterRule_MATCHWS();
	partial void LeaveRule_MATCHWS();

	// $ANTLR start "MATCHWS"
	[GrammarRule("MATCHWS")]
	private void mMATCHWS()
	{
		EnterRule_MATCHWS();
		EnterRule("MATCHWS", 40);
		TraceIn("MATCHWS", 40);
		try
		{
			int _type = MATCHWS;
			int _channel = DefaultTokenChannel;
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1004:12: ( ( WS )+ )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1004:16: ( WS )+
			{
			DebugLocation(1004, 16);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1004:16: ( WS )+
			int cnt9=0;
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if (((LA9_1>='\t' && LA9_1<='\n')||LA9_1=='\r'||LA9_1==' '))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// ../../QuoteFlow/Models/Search/Jql/Jql.g:
					{
					DebugLocation(1004, 16);
					input.Consume();


					}
					break;

				default:
					if (cnt9 >= 1)
						goto loop9;

					EarlyExitException eee9 = new EarlyExitException( 9, input );
					DebugRecognitionException(eee9);
					throw eee9;
				}
				cnt9++;
			}
			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(1004, 20);
			 _channel = HIDDEN; 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MATCHWS", 40);
			LeaveRule("MATCHWS", 40);
			LeaveRule_MATCHWS();
		}
	}
	// $ANTLR end "MATCHWS"

	partial void EnterRule_RESERVED_CHARS();
	partial void LeaveRule_RESERVED_CHARS();

	// $ANTLR start "RESERVED_CHARS"
	[GrammarRule("RESERVED_CHARS")]
	private void mRESERVED_CHARS()
	{
		EnterRule_RESERVED_CHARS();
		EnterRule("RESERVED_CHARS", 41);
		TraceIn("RESERVED_CHARS", 41);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1012:2: ( '{' | '}' | '*' | '/' | '%' | '+' | '^' | '$' | '#' | '@' | '?' | ';' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:
			{
			DebugLocation(1012, 2);
			if ((input.LA(1)>='#' && input.LA(1)<='%')||(input.LA(1)>='*' && input.LA(1)<='+')||input.LA(1)=='/'||input.LA(1)==';'||(input.LA(1)>='?' && input.LA(1)<='@')||input.LA(1)=='^'||input.LA(1)=='{'||input.LA(1)=='}')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("RESERVED_CHARS", 41);
			LeaveRule("RESERVED_CHARS", 41);
			LeaveRule_RESERVED_CHARS();
		}
	}
	// $ANTLR end "RESERVED_CHARS"

	partial void EnterRule_ERROR_RESERVED();
	partial void LeaveRule_ERROR_RESERVED();

	// $ANTLR start "ERROR_RESERVED"
	[GrammarRule("ERROR_RESERVED")]
	private void mERROR_RESERVED()
	{
		EnterRule_ERROR_RESERVED();
		EnterRule("ERROR_RESERVED", 42);
		TraceIn("ERROR_RESERVED", 42);
		try
		{
			int _type = ERROR_RESERVED;
			int _channel = DefaultTokenChannel;

			        pushPosition(ERROR_RESERVED);
			        recover();
			    
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1029:5: ( RESERVED_CHARS )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:
			{
			DebugLocation(1029, 5);
			if ((input.LA(1)>='#' && input.LA(1)<='%')||(input.LA(1)>='*' && input.LA(1)<='+')||input.LA(1)=='/'||input.LA(1)==';'||(input.LA(1)>='?' && input.LA(1)<='@')||input.LA(1)=='^'||input.LA(1)=='{'||input.LA(1)=='}')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
			 popPosition(); 
		}
		finally
		{
			TraceOut("ERROR_RESERVED", 42);
			LeaveRule("ERROR_RESERVED", 42);
			LeaveRule_ERROR_RESERVED();
		}
	}
	// $ANTLR end "ERROR_RESERVED"

	partial void EnterRule_ERRORCHAR();
	partial void LeaveRule_ERRORCHAR();

	// $ANTLR start "ERRORCHAR"
	[GrammarRule("ERRORCHAR")]
	private void mERRORCHAR()
	{
		EnterRule_ERRORCHAR();
		EnterRule("ERRORCHAR", 43);
		TraceIn("ERRORCHAR", 43);
		try
		{
			int _type = ERRORCHAR;
			int _channel = DefaultTokenChannel;

			        pushPosition(ERRORCHAR);
			        recover();
			    
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1044:5: ( . )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1044:7: .
			{
			DebugLocation(1044, 7);
			MatchAny(); 

			}

			state.type = _type;
			state.channel = _channel;
			 popPosition(); 
		}
		finally
		{
			TraceOut("ERRORCHAR", 43);
			LeaveRule("ERRORCHAR", 43);
			LeaveRule_ERRORCHAR();
		}
	}
	// $ANTLR end "ERRORCHAR"

	partial void EnterRule_QUOTE();
	partial void LeaveRule_QUOTE();

	// $ANTLR start "QUOTE"
	[GrammarRule("QUOTE")]
	private void mQUOTE()
	{
		EnterRule_QUOTE();
		EnterRule("QUOTE", 44);
		TraceIn("QUOTE", 44);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1043:17: ( '\"' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1043:19: '\"'
			{
			DebugLocation(1043, 19);
			Match('\"'); 

			}

		}
		finally
		{
			TraceOut("QUOTE", 44);
			LeaveRule("QUOTE", 44);
			LeaveRule_QUOTE();
		}
	}
	// $ANTLR end "QUOTE"

	partial void EnterRule_SQUOTE();
	partial void LeaveRule_SQUOTE();

	// $ANTLR start "SQUOTE"
	[GrammarRule("SQUOTE")]
	private void mSQUOTE()
	{
		EnterRule_SQUOTE();
		EnterRule("SQUOTE", 45);
		TraceIn("SQUOTE", 45);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1044:18: ( '\\'' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1044:20: '\\''
			{
			DebugLocation(1044, 20);
			Match('\''); 

			}

		}
		finally
		{
			TraceOut("SQUOTE", 45);
			LeaveRule("SQUOTE", 45);
			LeaveRule_SQUOTE();
		}
	}
	// $ANTLR end "SQUOTE"

	partial void EnterRule_BSLASH();
	partial void LeaveRule_BSLASH();

	// $ANTLR start "BSLASH"
	[GrammarRule("BSLASH")]
	private void mBSLASH()
	{
		EnterRule_BSLASH();
		EnterRule("BSLASH", 46);
		TraceIn("BSLASH", 46);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1045:18: ( '\\\\' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1045:20: '\\\\'
			{
			DebugLocation(1045, 20);
			Match('\\'); 

			}

		}
		finally
		{
			TraceOut("BSLASH", 46);
			LeaveRule("BSLASH", 46);
			LeaveRule_BSLASH();
		}
	}
	// $ANTLR end "BSLASH"

	partial void EnterRule_NL();
	partial void LeaveRule_NL();

	// $ANTLR start "NL"
	[GrammarRule("NL")]
	private void mNL()
	{
		EnterRule_NL();
		EnterRule("NL", 47);
		TraceIn("NL", 47);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1046:14: ( '\\r' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1046:16: '\\r'
			{
			DebugLocation(1046, 16);
			Match('\r'); 

			}

		}
		finally
		{
			TraceOut("NL", 47);
			LeaveRule("NL", 47);
			LeaveRule_NL();
		}
	}
	// $ANTLR end "NL"

	partial void EnterRule_CR();
	partial void LeaveRule_CR();

	// $ANTLR start "CR"
	[GrammarRule("CR")]
	private void mCR()
	{
		EnterRule_CR();
		EnterRule("CR", 48);
		TraceIn("CR", 48);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1047:14: ( '\\n' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1047:16: '\\n'
			{
			DebugLocation(1047, 16);
			Match('\n'); 

			}

		}
		finally
		{
			TraceOut("CR", 48);
			LeaveRule("CR", 48);
			LeaveRule_CR();
		}
	}
	// $ANTLR end "CR"

	partial void EnterRule_SPACE();
	partial void LeaveRule_SPACE();

	// $ANTLR start "SPACE"
	[GrammarRule("SPACE")]
	private void mSPACE()
	{
		EnterRule_SPACE();
		EnterRule("SPACE", 49);
		TraceIn("SPACE", 49);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1048:17: ( ' ' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1048:19: ' '
			{
			DebugLocation(1048, 19);
			Match(' '); 

			}

		}
		finally
		{
			TraceOut("SPACE", 49);
			LeaveRule("SPACE", 49);
			LeaveRule_SPACE();
		}
	}
	// $ANTLR end "SPACE"

	partial void EnterRule_AMPER();
	partial void LeaveRule_AMPER();

	// $ANTLR start "AMPER"
	[GrammarRule("AMPER")]
	private void mAMPER()
	{
		EnterRule_AMPER();
		EnterRule("AMPER", 50);
		TraceIn("AMPER", 50);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1049:16: ( '&' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1049:18: '&'
			{
			DebugLocation(1049, 18);
			Match('&'); 

			}

		}
		finally
		{
			TraceOut("AMPER", 50);
			LeaveRule("AMPER", 50);
			LeaveRule_AMPER();
		}
	}
	// $ANTLR end "AMPER"

	partial void EnterRule_AMPER_AMPER();
	partial void LeaveRule_AMPER_AMPER();

	// $ANTLR start "AMPER_AMPER"
	[GrammarRule("AMPER_AMPER")]
	private void mAMPER_AMPER()
	{
		EnterRule_AMPER_AMPER();
		EnterRule("AMPER_AMPER", 51);
		TraceIn("AMPER_AMPER", 51);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1050:21: ( '&&' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1050:24: '&&'
			{
			DebugLocation(1050, 24);
			Match("&&"); 


			}

		}
		finally
		{
			TraceOut("AMPER_AMPER", 51);
			LeaveRule("AMPER_AMPER", 51);
			LeaveRule_AMPER_AMPER();
		}
	}
	// $ANTLR end "AMPER_AMPER"

	partial void EnterRule_PIPE();
	partial void LeaveRule_PIPE();

	// $ANTLR start "PIPE"
	[GrammarRule("PIPE")]
	private void mPIPE()
	{
		EnterRule_PIPE();
		EnterRule("PIPE", 52);
		TraceIn("PIPE", 52);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1051:15: ( '|' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1051:17: '|'
			{
			DebugLocation(1051, 17);
			Match('|'); 

			}

		}
		finally
		{
			TraceOut("PIPE", 52);
			LeaveRule("PIPE", 52);
			LeaveRule_PIPE();
		}
	}
	// $ANTLR end "PIPE"

	partial void EnterRule_PIPE_PIPE();
	partial void LeaveRule_PIPE_PIPE();

	// $ANTLR start "PIPE_PIPE"
	[GrammarRule("PIPE_PIPE")]
	private void mPIPE_PIPE()
	{
		EnterRule_PIPE_PIPE();
		EnterRule("PIPE_PIPE", 53);
		TraceIn("PIPE_PIPE", 53);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1052:20: ( '||' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1052:22: '||'
			{
			DebugLocation(1052, 22);
			Match("||"); 


			}

		}
		finally
		{
			TraceOut("PIPE_PIPE", 53);
			LeaveRule("PIPE_PIPE", 53);
			LeaveRule_PIPE_PIPE();
		}
	}
	// $ANTLR end "PIPE_PIPE"

	partial void EnterRule_ESCAPE();
	partial void LeaveRule_ESCAPE();

	// $ANTLR start "ESCAPE"
	[GrammarRule("ESCAPE")]
	private void mESCAPE()
	{
		EnterRule_ESCAPE();
		EnterRule("ESCAPE", 54);
		TraceIn("ESCAPE", 54);
		try
		{
			 pushPosition(ESCAPE); 
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1060:2: ( BSLASH ( 't' | 'n' | 'r' | QUOTE | SQUOTE | BSLASH | SPACE | 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1060:6: BSLASH ( 't' | 'n' | 'r' | QUOTE | SQUOTE | BSLASH | SPACE | 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT )
			{
			DebugLocation(1060, 6);
			mBSLASH(); 
			DebugLocation(1061, 2);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1061:2: ( 't' | 'n' | 'r' | QUOTE | SQUOTE | BSLASH | SPACE | 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT )
			int alt10=8;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case 't':
				{
				alt10 = 1;
				}
				break;
			case 'n':
				{
				alt10 = 2;
				}
				break;
			case 'r':
				{
				alt10 = 3;
				}
				break;
			case '\"':
				{
				alt10 = 4;
				}
				break;
			case '\'':
				{
				alt10 = 5;
				}
				break;
			case '\\':
				{
				alt10 = 6;
				}
				break;
			case ' ':
				{
				alt10 = 7;
				}
				break;
			case 'u':
				{
				alt10 = 8;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:1062:15: 't'
				{
				DebugLocation(1062, 15);
				Match('t'); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:1063:17: 'n'
				{
				DebugLocation(1063, 17);
				Match('n'); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:1064:17: 'r'
				{
				DebugLocation(1064, 17);
				Match('r'); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:1065:17: QUOTE
				{
				DebugLocation(1065, 17);
				mQUOTE(); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:1066:17: SQUOTE
				{
				DebugLocation(1066, 17);
				mSQUOTE(); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:1067:17: BSLASH
				{
				DebugLocation(1067, 17);
				mBSLASH(); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:1068:17: SPACE
				{
				DebugLocation(1068, 17);
				mSPACE(); 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// ../../QuoteFlow/Models/Search/Jql/Jql.g:1069:16: 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT
				{
				DebugLocation(1069, 16);
				Match('u'); 
				DebugLocation(1069, 20);
				mHEXDIGIT(); 
				DebugLocation(1069, 29);
				mHEXDIGIT(); 
				DebugLocation(1069, 38);
				mHEXDIGIT(); 
				DebugLocation(1069, 47);
				mHEXDIGIT(); 

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(1070, 4);
			 popPosition(); 

			}

		}
		finally
		{
			TraceOut("ESCAPE", 54);
			LeaveRule("ESCAPE", 54);
			LeaveRule_ESCAPE();
		}
	}
	// $ANTLR end "ESCAPE"

	partial void EnterRule_STRINGSTOP();
	partial void LeaveRule_STRINGSTOP();

	// $ANTLR start "STRINGSTOP"
	[GrammarRule("STRINGSTOP")]
	private void mSTRINGSTOP()
	{
		EnterRule_STRINGSTOP();
		EnterRule("STRINGSTOP", 55);
		TraceIn("STRINGSTOP", 55);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1080:2: ( CONTROLCHARS | QUOTE | SQUOTE | EQUALS | BANG | LT | GT | LPAREN | RPAREN | LIKE | COMMA | LBRACKET | RBRACKET | PIPE | AMPER | RESERVED_CHARS | NEWLINE )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:
			{
			DebugLocation(1080, 2);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='\u001F')||(input.LA(1)>='!' && input.LA(1)<=',')||input.LA(1)=='/'||(input.LA(1)>=';' && input.LA(1)<='@')||input.LA(1)=='['||(input.LA(1)>=']' && input.LA(1)<='^')||(input.LA(1)>='{' && input.LA(1)<='\u009F')||(input.LA(1)>='\uFDD0' && input.LA(1)<='\uFDEF')||(input.LA(1)>='\uFFFE' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("STRINGSTOP", 55);
			LeaveRule("STRINGSTOP", 55);
			LeaveRule_STRINGSTOP();
		}
	}
	// $ANTLR end "STRINGSTOP"

	partial void EnterRule_CONTROLCHARS();
	partial void LeaveRule_CONTROLCHARS();

	// $ANTLR start "CONTROLCHARS"
	[GrammarRule("CONTROLCHARS")]
	private void mCONTROLCHARS()
	{
		EnterRule_CONTROLCHARS();
		EnterRule("CONTROLCHARS", 56);
		TraceIn("CONTROLCHARS", 56);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1098:2: ( '\\u0000' .. '\\u0009' | '\\u000b' .. '\\u000c' | '\\u000e' .. '\\u001f' | '\\u007f' .. '\\u009f' | '\\ufdd0' .. '\\ufdef' | '\\ufffe' .. '\\uffff' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:
			{
			DebugLocation(1098, 2);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='\t')||(input.LA(1)>='\u000B' && input.LA(1)<='\f')||(input.LA(1)>='\u000E' && input.LA(1)<='\u001F')||(input.LA(1)>='\u007F' && input.LA(1)<='\u009F')||(input.LA(1)>='\uFDD0' && input.LA(1)<='\uFDEF')||(input.LA(1)>='\uFFFE' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("CONTROLCHARS", 56);
			LeaveRule("CONTROLCHARS", 56);
			LeaveRule_CONTROLCHARS();
		}
	}
	// $ANTLR end "CONTROLCHARS"

	partial void EnterRule_NEWLINE();
	partial void LeaveRule_NEWLINE();

	// $ANTLR start "NEWLINE"
	[GrammarRule("NEWLINE")]
	private void mNEWLINE()
	{
		EnterRule_NEWLINE();
		EnterRule("NEWLINE", 57);
		TraceIn("NEWLINE", 57);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1113:5: ( NL | CR )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:
			{
			DebugLocation(1113, 5);
			if (input.LA(1)=='\n'||input.LA(1)=='\r')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("NEWLINE", 57);
			LeaveRule("NEWLINE", 57);
			LeaveRule_NEWLINE();
		}
	}
	// $ANTLR end "NEWLINE"

	partial void EnterRule_HEXDIGIT();
	partial void LeaveRule_HEXDIGIT();

	// $ANTLR start "HEXDIGIT"
	[GrammarRule("HEXDIGIT")]
	private void mHEXDIGIT()
	{
		EnterRule_HEXDIGIT();
		EnterRule("HEXDIGIT", 58);
		TraceIn("HEXDIGIT", 58);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1116:2: ( DIGIT | ( 'A' | 'a' ) | ( 'B' | 'b' ) | ( 'C' | 'c' ) | ( 'D' | 'd' ) | ( 'E' | 'e' ) | ( 'F' | 'f' ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:
			{
			DebugLocation(1116, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("HEXDIGIT", 58);
			LeaveRule("HEXDIGIT", 58);
			LeaveRule_HEXDIGIT();
		}
	}
	// $ANTLR end "HEXDIGIT"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 59);
		TraceIn("DIGIT", 59);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1120:2: ( '0' .. '9' )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:
			{
			DebugLocation(1120, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("DIGIT", 59);
			LeaveRule("DIGIT", 59);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 60);
		TraceIn("WS", 60);
		try
		{
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1124:2: ( ( SPACE | '\\t' | NEWLINE ) )
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:
			{
			DebugLocation(1124, 2);
			if ((input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("WS", 60);
			LeaveRule("WS", 60);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	public override void mTokens()
	{
		// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:8: ( LPAREN | RPAREN | COMMA | LBRACKET | RBRACKET | BANG | LT | GT | GTEQ | LTEQ | EQUALS | NOT_EQUALS | LIKE | NOT_LIKE | IN | IS | AND | OR | NOT | EMPTY | WAS | CHANGED | BEFORE | AFTER | FROM | TO | ON | DURING | ORDER | BY | ASC | DESC | POSNUMBER | NEGNUMBER | CUSTOMFIELD | STRING | QUOTE_STRING | SQUOTE_STRING | MATCHWS | ERROR_RESERVED | ERRORCHAR )
		int alt11=41;
		try { DebugEnterDecision(11, false);
		try
		{
			alt11 = dfa11.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(11); }
		switch (alt11)
		{
		case 1:
			DebugEnterAlt(1);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:10: LPAREN
			{
			DebugLocation(1, 10);
			mLPAREN(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:17: RPAREN
			{
			DebugLocation(1, 17);
			mRPAREN(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:24: COMMA
			{
			DebugLocation(1, 24);
			mCOMMA(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:30: LBRACKET
			{
			DebugLocation(1, 30);
			mLBRACKET(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:39: RBRACKET
			{
			DebugLocation(1, 39);
			mRBRACKET(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:48: BANG
			{
			DebugLocation(1, 48);
			mBANG(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:53: LT
			{
			DebugLocation(1, 53);
			mLT(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:56: GT
			{
			DebugLocation(1, 56);
			mGT(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:59: GTEQ
			{
			DebugLocation(1, 59);
			mGTEQ(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:64: LTEQ
			{
			DebugLocation(1, 64);
			mLTEQ(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:69: EQUALS
			{
			DebugLocation(1, 69);
			mEQUALS(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:76: NOT_EQUALS
			{
			DebugLocation(1, 76);
			mNOT_EQUALS(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:87: LIKE
			{
			DebugLocation(1, 87);
			mLIKE(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:92: NOT_LIKE
			{
			DebugLocation(1, 92);
			mNOT_LIKE(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:101: IN
			{
			DebugLocation(1, 101);
			mIN(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:104: IS
			{
			DebugLocation(1, 104);
			mIS(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:107: AND
			{
			DebugLocation(1, 107);
			mAND(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:111: OR
			{
			DebugLocation(1, 111);
			mOR(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:114: NOT
			{
			DebugLocation(1, 114);
			mNOT(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:118: EMPTY
			{
			DebugLocation(1, 118);
			mEMPTY(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:124: WAS
			{
			DebugLocation(1, 124);
			mWAS(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:128: CHANGED
			{
			DebugLocation(1, 128);
			mCHANGED(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:136: BEFORE
			{
			DebugLocation(1, 136);
			mBEFORE(); 

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:143: AFTER
			{
			DebugLocation(1, 143);
			mAFTER(); 

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:149: FROM
			{
			DebugLocation(1, 149);
			mFROM(); 

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:154: TO
			{
			DebugLocation(1, 154);
			mTO(); 

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:157: ON
			{
			DebugLocation(1, 157);
			mON(); 

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:160: DURING
			{
			DebugLocation(1, 160);
			mDURING(); 

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:167: ORDER
			{
			DebugLocation(1, 167);
			mORDER(); 

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:173: BY
			{
			DebugLocation(1, 173);
			mBY(); 

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:176: ASC
			{
			DebugLocation(1, 176);
			mASC(); 

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:180: DESC
			{
			DebugLocation(1, 180);
			mDESC(); 

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:185: POSNUMBER
			{
			DebugLocation(1, 185);
			mPOSNUMBER(); 

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:195: NEGNUMBER
			{
			DebugLocation(1, 195);
			mNEGNUMBER(); 

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:205: CUSTOMFIELD
			{
			DebugLocation(1, 205);
			mCUSTOMFIELD(); 

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:217: STRING
			{
			DebugLocation(1, 217);
			mSTRING(); 

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:224: QUOTE_STRING
			{
			DebugLocation(1, 224);
			mQUOTE_STRING(); 

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:237: SQUOTE_STRING
			{
			DebugLocation(1, 237);
			mSQUOTE_STRING(); 

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:251: MATCHWS
			{
			DebugLocation(1, 251);
			mMATCHWS(); 

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:259: ERROR_RESERVED
			{
			DebugLocation(1, 259);
			mERROR_RESERVED(); 

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// ../../QuoteFlow/Models/Search/Jql/Jql.g:1:274: ERRORCHAR
			{
			DebugLocation(1, 274);
			mERRORCHAR(); 

			}
			break;

		}

	}


	#region DFA
	DFA11 dfa11;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa11 = new DFA11(this, SpecialStateTransition11);
	}

	private class DFA11 : DFA
	{
		private const string DFA11_eotS =
			"\x6\xFFFF\x1\x28\x1\x2A\x1\x2C\x2\xFFFF\x2\x31\x1\xFFFF\x1\x31\x1\xFFFF"+
			"\x8\x31\x1\x45\x1\x31\x1\x20\x1\xFFFF\x2\x20\x11\xFFFF\x1\x4C\x1\x4D"+
			"\x1\xFFFF\x3\x31\x1\xFFFF\x1\x38\x1\x52\x1\xFFFF\x5\x31\x1\x58\x1\x31"+
			"\x1\x5A\x1\x31\x1\x5C\x2\x31\x1\xFFFF\x1\x45\x1\x5F\x6\xFFFF\x1\x35\x1"+
			"\x31\x1\x61\x1\x31\x1\xFFFF\x1\x63\x2\x31\x1\x66\x1\x31\x1\xFFFF\x1\x31"+
			"\x1\xFFFF\x1\x31\x1\xFFFF\x2\x31\x1\xFFFF\x1\x31\x1\xFFFF\x1\x31\x1\xFFFF"+
			"\x1\x6E\x1\x31\x1\xFFFF\x2\x31\x1\x72\x1\x31\x1\x74\x1\x75\x1\x76\x1"+
			"\xFFFF\x1\x6E\x2\x31\x1\xFFFF\x1\x31\x3\xFFFF\x1\x31\x1\x7B\x1\x7C\x1"+
			"\x7D\x3\xFFFF";
		private const string DFA11_eofS =
			"\x7E\xFFFF";
		private const string DFA11_minS =
			"\x1\x0\x5\xFFFF\x3\x3D\x2\xFFFF\x1\x4E\x1\x46\x1\xFFFF\x1\x4E\x1\xFFFF"+
			"\x1\x4F\x1\x4D\x1\x41\x1\x46\x1\x45\x1\x52\x1\x4F\x1\x45\x1\x2D\x1\x30"+
			"\x1\x20\x1\xFFFF\x2\xA\x11\xFFFF\x2\x2D\x1\xFFFF\x1\x44\x1\x54\x1\x43"+
			"\x1\xFFFF\x2\x2D\x1\xFFFF\x1\x54\x1\x4C\x1\x50\x1\x53\x1\x41\x1\x2D\x1"+
			"\x46\x1\x2D\x1\x4F\x1\x2D\x1\x52\x1\x53\x1\xFFFF\x2\x2D\x6\xFFFF\x1\x2D"+
			"\x1\x45\x1\x2D\x1\x45\x1\xFFFF\x1\x2D\x1\x4C\x1\x54\x1\x2D\x1\x4E\x1"+
			"\xFFFF\x1\x4F\x1\xFFFF\x1\x4D\x1\xFFFF\x1\x49\x1\x43\x1\xFFFF\x1\x52"+
			"\x1\xFFFF\x1\x52\x1\xFFFF\x1\x2D\x1\x59\x1\xFFFF\x1\x47\x1\x52\x1\x2D"+
			"\x1\x4E\x3\x2D\x1\xFFFF\x1\x2D\x2\x45\x1\xFFFF\x1\x47\x3\xFFFF\x1\x44"+
			"\x3\x2D\x3\xFFFF";
		private const string DFA11_maxS =
			"\x1\xFFFF\x5\xFFFF\x1\x7E\x2\x3D\x2\xFFFF\x2\x73\x1\xFFFF\x1\x72\x1\xFFFF"+
			"\x1\x75\x1\x6D\x1\x61\x1\x68\x1\x79\x1\x72\x1\x6F\x1\x75\x1\xFFFD\x1"+
			"\x39\x1\x75\x1\xFFFF\x2\xFFFD\x11\xFFFF\x2\xFFFD\x1\xFFFF\x1\x64\x1\x74"+
			"\x1\x63\x1\xFFFF\x2\xFFFD\x1\xFFFF\x1\x74\x1\x6C\x1\x70\x1\x73\x1\x61"+
			"\x1\xFFFD\x1\x66\x1\xFFFD\x1\x6F\x1\xFFFD\x1\x72\x1\x73\x1\xFFFF\x2\xFFFD"+
			"\x6\xFFFF\x1\xFFFD\x1\x65\x1\xFFFD\x1\x65\x1\xFFFF\x1\xFFFD\x1\x6C\x1"+
			"\x74\x1\xFFFD\x1\x6E\x1\xFFFF\x1\x6F\x1\xFFFF\x1\x6D\x1\xFFFF\x1\x69"+
			"\x1\x63\x1\xFFFF\x1\x72\x1\xFFFF\x1\x72\x1\xFFFF\x1\xFFFD\x1\x79\x1\xFFFF"+
			"\x1\x67\x1\x72\x1\xFFFD\x1\x6E\x3\xFFFD\x1\xFFFF\x1\xFFFD\x2\x65\x1\xFFFF"+
			"\x1\x67\x3\xFFFF\x1\x64\x3\xFFFD\x3\xFFFF";
		private const string DFA11_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x3\xFFFF\x1\xB\x1\xD\x2\xFFFF"+
			"\x1\x11\x1\xFFFF\x1\x12\xB\xFFFF\x1\x24\x2\xFFFF\x1\x27\x1\x28\x1\x29"+
			"\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\xC\x1\xE\x1\x6\x1\xA\x1\x7\x1\x9\x1"+
			"\x8\x1\xB\x1\xD\x2\xFFFF\x1\x24\x3\xFFFF\x1\x11\x2\xFFFF\x1\x12\xC\xFFFF"+
			"\x1\x21\x2\xFFFF\x1\x25\x1\x26\x1\x27\x1\x28\x1\xF\x1\x10\x4\xFFFF\x1"+
			"\x1B\x5\xFFFF\x1\x23\x1\xFFFF\x1\x1E\x1\xFFFF\x1\x1A\x2\xFFFF\x1\x22"+
			"\x1\xFFFF\x1\x1F\x1\xFFFF\x1\x13\x2\xFFFF\x1\x15\x7\xFFFF\x1\x14\x3\xFFFF"+
			"\x1\x19\x1\xFFFF\x1\x20\x1\x18\x1\x1D\x4\xFFFF\x1\x17\x1\x1C\x1\x16";
		private const string DFA11_specialS =
			"\x1\x0\x7D\xFFFF}>";
		private static readonly string[] DFA11_transitionS =
			{
				"\x9\x20\x2\x1E\x2\x20\x1\x1E\x12\x20\x1\x1E\x1\x6\x1\x1C\x3\x1F\x1\xD"+
				"\x1\x1D\x1\x1\x1\x2\x2\x1F\x1\x3\x1\x19\x1\x1B\x1\x1F\xA\x18\x1\x1B"+
				"\x1\x1F\x1\x7\x1\x9\x1\x8\x2\x1F\x1\xC\x1\x14\x1\x13\x1\x17\x1\x11\x1"+
				"\x15\x2\x1B\x1\xB\x4\x1B\x1\x10\x1\xE\x4\x1B\x1\x16\x2\x1B\x1\x12\x3"+
				"\x1B\x1\x4\x1\x1A\x1\x5\x1\x1F\x2\x1B\x1\xC\x1\x14\x1\x13\x1\x17\x1"+
				"\x11\x1\x15\x2\x1B\x1\xB\x4\x1B\x1\x10\x1\xE\x4\x1B\x1\x16\x2\x1B\x1"+
				"\x12\x3\x1B\x1\x1F\x1\xF\x1\x1F\x1\xA\x21\x20\xFD30\x1B\x20\x20\x20E"+
				"\x1B\x2\x20",
				"",
				"",
				"",
				"",
				"",
				"\x1\x26\x40\xFFFF\x1\x27",
				"\x1\x29",
				"\x1\x2B",
				"",
				"",
				"\x1\x2F\x4\xFFFF\x1\x30\x1A\xFFFF\x1\x2F\x4\xFFFF\x1\x30",
				"\x1\x33\x7\xFFFF\x1\x32\x4\xFFFF\x1\x34\x12\xFFFF\x1\x33\x7\xFFFF\x1"+
				"\x32\x4\xFFFF\x1\x34",
				"",
				"\x1\x37\x3\xFFFF\x1\x36\x1B\xFFFF\x1\x37\x3\xFFFF\x1\x36",
				"",
				"\x1\x39\x5\xFFFF\x1\x3A\x19\xFFFF\x1\x39\x5\xFFFF\x1\x3A",
				"\x1\x3B\x1F\xFFFF\x1\x3B",
				"\x1\x3C\x1F\xFFFF\x1\x3C",
				"\x1\x3E\x1\xFFFF\x1\x3D\x1D\xFFFF\x1\x3E\x1\xFFFF\x1\x3D",
				"\x1\x3F\x13\xFFFF\x1\x40\xB\xFFFF\x1\x3F\x13\xFFFF\x1\x40",
				"\x1\x41\x1F\xFFFF\x1\x41",
				"\x1\x42\x1F\xFFFF\x1\x42",
				"\x1\x44\xF\xFFFF\x1\x43\xF\xFFFF\x1\x44\xF\xFFFF\x1\x43",
				"\x2\x31\x1\xFFFF\xA\x46\x1\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF"+
				"\x1C\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\xA\x47",
				"\x1\x31\x1\xFFFF\x1\x31\x4\xFFFF\x1\x31\x34\xFFFF\x1\x31\x11\xFFFF\x1"+
				"\x31\x3\xFFFF\x1\x31\x1\xFFFF\x2\x31",
				"",
				"\x1\x48\x2\xFFFF\x1\x48\x12\xFFFF\x5F\x48\x21\xFFFF\xFD30\x48\x20\xFFFF"+
				"\x20E\x48",
				"\x1\x49\x2\xFFFF\x1\x49\x12\xFFFF\x5F\x49\x21\xFFFF\xFD30\x49\x20\xFFFF"+
				"\x20E\x49",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"",
				"\x1\x4E\x1F\xFFFF\x1\x4E",
				"\x1\x4F\x1F\xFFFF\x1\x4F",
				"\x1\x50\x1F\xFFFF\x1\x50",
				"",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x3\x31\x1\x51\x16\x31\x1\xFFFF\x1\x31"+
				"\x2\xFFFF\x5\x31\x1\x51\x16\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"",
				"\x1\x53\x1F\xFFFF\x1\x53",
				"\x1\x54\x1F\xFFFF\x1\x54",
				"\x1\x55\x1F\xFFFF\x1\x55",
				"\x1\x56\x1F\xFFFF\x1\x56",
				"\x1\x57\x1F\xFFFF\x1\x57",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x1\x59\x1F\xFFFF\x1\x59",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x1\x5B\x1F\xFFFF\x1\x5B",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x1\x5D\x1F\xFFFF\x1\x5D",
				"\x1\x5E\x1F\xFFFF\x1\x5E",
				"",
				"\x2\x31\x1\xFFFF\xA\x46\x1\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF"+
				"\x1C\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x2\x31\x1\xFFFF\xA\x47\x1\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF"+
				"\x1C\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x1\x60\x1F\xFFFF\x1\x60",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x1\x62\x1F\xFFFF\x1\x62",
				"",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x1\x64\x1F\xFFFF\x1\x64",
				"\x1\x65\x1F\xFFFF\x1\x65",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x1\x67\x1F\xFFFF\x1\x67",
				"",
				"\x1\x68\x1F\xFFFF\x1\x68",
				"",
				"\x1\x69\x1F\xFFFF\x1\x69",
				"",
				"\x1\x6A\x1F\xFFFF\x1\x6A",
				"\x1\x6B\x1F\xFFFF\x1\x6B",
				"",
				"\x1\x6C\x1F\xFFFF\x1\x6C",
				"",
				"\x1\x6D\x1F\xFFFF\x1\x6D",
				"",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x1\x6F\x1F\xFFFF\x1\x6F",
				"",
				"\x1\x70\x1F\xFFFF\x1\x70",
				"\x1\x71\x1F\xFFFF\x1\x71",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x1\x73\x1F\xFFFF\x1\x73",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x1\x77\x1F\xFFFF\x1\x77",
				"\x1\x78\x1F\xFFFF\x1\x78",
				"",
				"\x1\x79\x1F\xFFFF\x1\x79",
				"",
				"",
				"",
				"\x1\x7A\x1F\xFFFF\x1\x7A",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"\x2\x31\x1\xFFFF\xB\x31\x6\xFFFF\x1A\x31\x1\xFFFF\x1\x31\x2\xFFFF\x1C"+
				"\x31\x25\xFFFF\xFD30\x31\x20\xFFFF\x20E\x31",
				"",
				"",
				""
			};

		private static readonly short[] DFA11_eot = DFA.UnpackEncodedString(DFA11_eotS);
		private static readonly short[] DFA11_eof = DFA.UnpackEncodedString(DFA11_eofS);
		private static readonly char[] DFA11_min = DFA.UnpackEncodedStringToUnsignedChars(DFA11_minS);
		private static readonly char[] DFA11_max = DFA.UnpackEncodedStringToUnsignedChars(DFA11_maxS);
		private static readonly short[] DFA11_accept = DFA.UnpackEncodedString(DFA11_acceptS);
		private static readonly short[] DFA11_special = DFA.UnpackEncodedString(DFA11_specialS);
		private static readonly short[][] DFA11_transition;

		static DFA11()
		{
			int numStates = DFA11_transitionS.Length;
			DFA11_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA11_transition[i] = DFA.UnpackEncodedString(DFA11_transitionS[i]);
			}
		}

		public DFA11( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 11;
			this.eot = DFA11_eot;
			this.eof = DFA11_eof;
			this.min = DFA11_min;
			this.max = DFA11_max;
			this.accept = DFA11_accept;
			this.special = DFA11_special;
			this.transition = DFA11_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( LPAREN | RPAREN | COMMA | LBRACKET | RBRACKET | BANG | LT | GT | GTEQ | LTEQ | EQUALS | NOT_EQUALS | LIKE | NOT_LIKE | IN | IS | AND | OR | NOT | EMPTY | WAS | CHANGED | BEFORE | AFTER | FROM | TO | ON | DURING | ORDER | BY | ASC | DESC | POSNUMBER | NEGNUMBER | CUSTOMFIELD | STRING | QUOTE_STRING | SQUOTE_STRING | MATCHWS | ERROR_RESERVED | ERRORCHAR );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition11(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		s = -1;
		int LA11_1 = input.LA(1);
		int index11_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				if ((LA11_1=='(')) {s = 1;}

				else if ((LA11_1==')')) {s = 2;}

				else if ((LA11_1==',')) {s = 3;}

				else if ((LA11_1=='[')) {s = 4;}

				else if ((LA11_1==']')) {s = 5;}

				else if ((LA11_1=='!')) {s = 6;}

				else if ((LA11_1=='<')) {s = 7;}

				else if ((LA11_1=='>')) {s = 8;}

				else if ((LA11_1=='=')) {s = 9;}

				else if ((LA11_1=='~')) {s = 10;}

				else if ((LA11_1=='I'||LA11_1=='i')) {s = 11;}

				else if ((LA11_1=='A'||LA11_1=='a')) {s = 12;}

				else if ((LA11_1=='&')) {s = 13;}

				else if ((LA11_1=='O'||LA11_1=='o')) {s = 14;}

				else if ((LA11_1=='|')) {s = 15;}

				else if ((LA11_1=='N'||LA11_1=='n')) {s = 16;}

				else if ((LA11_1=='E'||LA11_1=='e')) {s = 17;}

				else if ((LA11_1=='W'||LA11_1=='w')) {s = 18;}

				else if ((LA11_1=='C'||LA11_1=='c')) {s = 19;}

				else if ((LA11_1=='B'||LA11_1=='b')) {s = 20;}

				else if ((LA11_1=='F'||LA11_1=='f')) {s = 21;}

				else if ((LA11_1=='T'||LA11_1=='t')) {s = 22;}

				else if ((LA11_1=='D'||LA11_1=='d')) {s = 23;}

				else if (((LA11_1>='0' && LA11_1<='9'))) {s = 24;}

				else if ((LA11_1=='-')) {s = 25;}

				else if ((LA11_1=='\\')) {s = 26;}

				else if ((LA11_1=='.'||LA11_1==':'||(LA11_1>='G' && LA11_1<='H')||(LA11_1>='J' && LA11_1<='M')||(LA11_1>='P' && LA11_1<='S')||(LA11_1>='U' && LA11_1<='V')||(LA11_1>='X' && LA11_1<='Z')||(LA11_1>='_' && LA11_1<='`')||(LA11_1>='g' && LA11_1<='h')||(LA11_1>='j' && LA11_1<='m')||(LA11_1>='p' && LA11_1<='s')||(LA11_1>='u' && LA11_1<='v')||(LA11_1>='x' && LA11_1<='z')||(LA11_1>='\u00A0' && LA11_1<='\uFDCF')||(LA11_1>='\uFDF0' && LA11_1<='\uFFFD'))) {s = 27;}

				else if ((LA11_1=='\"')) {s = 28;}

				else if ((LA11_1=='\'')) {s = 29;}

				else if (((LA11_1>='\t' && LA11_1<='\n')||LA11_1=='\r'||LA11_1==' ')) {s = 30;}

				else if (((LA11_1>='#' && LA11_1<='%')||(LA11_1>='*' && LA11_1<='+')||LA11_1=='/'||LA11_1==';'||(LA11_1>='?' && LA11_1<='@')||LA11_1=='^'||LA11_1=='{'||LA11_1=='}')) {s = 31;}

				else if (((LA11_1>='\u0000' && LA11_1<='\b')||(LA11_1>='\u000B' && LA11_1<='\f')||(LA11_1>='\u000E' && LA11_1<='\u001F')||(LA11_1>='\u007F' && LA11_1<='\u009F')||(LA11_1>='\uFDD0' && LA11_1<='\uFDEF')||(LA11_1>='\uFFFE' && LA11_1<='\uFFFF'))) {s = 32;}

				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		NoViableAltException nvae = new NoViableAltException(dfa.Description, 11, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion

}

} // namespace  QuoteFlow.Models.Search.Jql.AntlrGen 
